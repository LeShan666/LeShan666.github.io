<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[渐进记号]]></title>
    <url>%2F2019%2F01%2F31%2F%E6%B8%90%E8%BF%9B%E8%AE%B0%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[渐进记号&emsp;&emsp;在算法分析里面对算法运行时间以及效率问题分析时，当n的规模变得足够大时，我们引入了渐进分析记号$\Theta$来描述当输入规模无限大时，算法运行时间如何随输入规模变大而变大，现在来记录一下另外几种渐进记号约定，用来刻画算法某个其他其他方面的函数(空间与时间)。 &emsp;&emsp;在了解算法运行时间时，我们有时也要在意到底需要哪个运行时间，不是所有时候都需要最坏运行时间，我们希望有一个综合性的来刻画任何输入的运行时间，所以我们需要更多的渐进记号。 1. $\Theta$记号&emsp;&emsp;在分析插入排序与归并排序的运行时间时引入了这个记号插入排序的最坏运行时间为T(n)=$\Theta$(n2)，而归并排序只有T(n)=$\Theta$(nlgn)。&emsp;&emsp;来重新定义一下这个记号，对于一个给定的g(n)，用$\Theta$(n)表示一个函数集合： $\Theta$(g(n)) = {f(n):存在正常量c1、c2和n0，使得所有n &gt;= n0,有0 &lt;= c1g(n) &lt;= f(n) &lt;= c2g(n)} &emsp;&emsp;若存在正常量c1、c2能够在n足够大时，让函数夹在c1g(n)与c2g(n)之间，则f(n)就属于$\Theta$(g(n)),这里的$\Theta$(g(n))是一个函数集合，而非一个函数，所以我在算法分析里简单的把$\Theta$记为了去掉低阶项，忽略系数，这是一个非形式化的概念。在下面的图像中可以看出f(n)高于c1g(n)或者低于c2g(n)，换一句话说，对于所有的n&gt;=n0,f(n)存在一个常量因子等于g(n)，我们称g(n)为f(n)的渐进紧确界。 &emsp;&emsp;$\Theta$(g(n))要求其内的每一个成员f(n)都渐进非负，即n足够大时，f(n)非负(g(n)本身也必须非负，否则集合$\Theta$(g(n))为0)，这个要求对其他符号也成立。 $\Theta$符号有一个活用，当出现$\Theta$(1)时，并没有什么变量趋于无穷，所以$\Theta$(1)用来指任意一个常量或者某个关于变量的常量函数，其他符号也一样。 2. O记号&emsp;&emsp;当我们只需要一个函数的渐进上界的时候，我们采用O记号来表示。对于给定的函数g(n)，用O(g(n))来表示一下函数集合： O(g(n)) = {f(n)：存在正常量c和n0，使得对所有n &gt;= n0，有0 &lt;= f(n) &lt;= cg(n)}。 &emsp;&emsp;用O给出了一个函数在常量因子中的一个上界，从图中可以看出，在n0及其有边的所有n值中，f(n)总是小于或者等于cg(n)。 &emsp;&emsp;f(n)=$\Theta$(g(n))是一个比f(n)=O(g(n))更强的概念，f(n)=$\Theta$(g(n))包含f(n)=O(g(n))，按照集合论的方法，写作$\Theta$(g(n)) $\subseteq$ O(g(n))，所以如果证明了任意二次函数 an2+bn+c a &gt; 0 如果证明了该函数在$\Theta$(n2)中，也就证明了这个函数在O(n2)中，任意线性函数an+b a &gt; 0也在O(n2)中。&emsp;&emsp;O记号可以仅仅通过检查算法的总体结构来描述算法的运行时间，例如插入排序的双重循环结构中就会产生一个O(n2)的上界：内层循环的每一次代价至多为O(1)，下标i与j均最多为n，双重循环会产生至多n2次访问。&emsp;&emsp;O通常用来修限制算法的最坏运行时间，在每一次输入时，对于插入排序的最坏时间O(n2)适用于每一个输入。但是在插入排序最坏运行时间$\Theta$(n2)并不意味着每一次输入运行时间界都是$\Theta$(n2)，例如当输入已经被排序时，这时候运行时间界就是$\Theta$(n)。&emsp;&emsp;一般当我们说“运行时间为O(n2)”时，指存在一个O(n2)的函数f(n)，使得对任意n，不管选择什么特定规模的n输入，运行时间上界都是f(n)，这就是运行的最坏情况时间为O(n2)。 3. Ω记号&emsp;&emsp;有运行时间上界，当然对应的也有运行时间下界，称为函数的渐进下界，用符号Ω表示，对于给定的函数g(n)，用Ω(g(n))来表示一下函数集合： Ω(g(n)) = {f(n):存在正常量c&lt;和n0，使得所有n&gt;=n0,有0 &lt;= cg(n) &lt;= f(n)} 下图可以直观解释Ω记号的含义，这里不说太多。 &emsp;&emsp;根据上面三个符号的定义，很容易得出一个定理 对于任意两个函数f(n)与g(n)，有f(n)=$\Theta$(g(n))，当且仅当f(n) = O(g(n))且f(n) = Ω(g(n))。 &emsp;&emsp;当存在二次函数an2+bn+c a &gt; 0时，有an2+bn+c = $\Theta$(n)时，同时说明了an2+bn+c = O(n)、an2+bn+c = Ω(n)，通常用渐进上界与渐进下界来证明渐进紧确界，当一个算法的运行时间为Ω(g(n))时，对于每个值，不管选择什么输入，n足够大时，他的时间都是g(n)的整数倍，说插入排序的最好运行时间为Ω(n)，蕴含着插入排序的运行时间为Ω(n)。&emsp;&emsp;所以称插入排序的运行时间介于Ω(n)和O(n2)之间，落入n的线性函数与n的二次函数之间的任何地方。插入排序运行时间不是Ω(n2)因为存在输入使得其能在$\Theta$(n)时间内运行。如果说插入排序运行最坏运行时间为Ω(n2)并不错误，因为存在一个输入使得该算法运行时间为Ω(n2)。 4. 等式与不等式&emsp;&emsp;在渐进记号中的等号两端并非等价的，一般渐进记号在等式(或不等式)右端时，通常指集合的成员关系，比如n = O(n2)指n $\in$ O(n2)，我们将公式中的渐进记号解释为不带名称的匿名函数。入2n2+3n+1 = 2n2+$\Theta$(n),这里的$\Theta$(n)指在$\Theta$(n)集合之内的一个函数。&emsp;&emsp;这种方式可以帮我们消除等式中一些无关紧要的细节，如果只对某个算法的渐进行为感兴趣，就没必要说明所有的低阶项，都被理解为包含在了$\Theta$(n)表示的匿名函数中。&emsp;&emsp;某些情况下渐进记号可能出现在等式左边，如： 2n2+$\Theta$(n) = $\Theta$(n2) 无论怎样选择等号左边的匿名函数，总有一种办法来选择等号右边的匿名函数使等式成立。在2n2+$\Theta$(n) = $\Theta$(n2)中我们可以取$\Theta$(n)集合中的3n+1，使等式变为2n2+3n+1 = $\Theta$(n2)，这样2n2+$\Theta$(n)就在$\Theta$(n2)集合之内，可以说等式左边提供的细节比等式右边更粗糙。 5. o记号与ω记号&emsp;&emsp;O记号与Ω记号可能并非渐进紧却的，比如2n2 = O(n2)是渐进紧却的，而2n = O(n2)就不是渐进紧却的，我们用小写的o与ω定义集合。 o(g(n)) = {f(n):对任意正常量c&gt;0,存在常量n0&gt;0，使得所有n &gt;= n0,有0 &lt;= f(n) &lt; cg(n)},如2n = o(n2)但2n2 $\neq$ o(n2)。 ω(g(n)) = {f(n):对任意正常量c &gt; 0,存在常量n0 &gt; 0，使得所有n &gt;= n0,有0 &lt;= cg(n) &lt; f(n)}，如n2/2 = ω(n),而2n $\neq$ ω(n)。 &emsp;&emsp;这两个符号都是非渐进紧却的，与O记号和Ω记号最大的不同是，o记号与ω记号并不能等于g(n)关于c常量的函数。 f(n) $\in$ ω(g(n)),当且仅当 g(n) $\in$ o(f(n)) &emsp;&emsp;将f与g类比为实数a和b。 记号 含义 类比 $\Theta$ 渐进紧却界 a = b O 渐进上界 a &lt;= b Ω 渐进下界 a &gt;= b o 非紧却上界 a &lt; b ω 非紧却下界 a &gt; b 6. 函数比较&emsp;&emsp;实数的很多性质都适用于函数的渐进比较，设f(n)和g(n)渐进为正。 6.1 传递性 f(n) = $\Theta$(g(n)) 且 g(n) = $\Theta$(h(n)) 蕴含 f(n) = $\Theta$(h(n))f(n) = O(g(n)) 且 g(n) = O(h(n)) 蕴含 f(n) = O(h(n))f(n) = Ω(g(n)) 且 g(n) = Ω(h(n)) 蕴含 f(n) = Ω(h(n))f(n) = o(g(n)) 且 g(n) = o(h(n)) 蕴含 f(n) = o(h(n))f(n) = ω(g(n)) 且 g(n) = ω(h(n)) 蕴含 f(n) = ω(h(n)) 6.2 自反性 f(n) = $\Theta$f(n)f(n) = Of(n)f(n) =Ωf(n) 6.3 对称性 f(n) = $\Theta$(g(n)) 当且仅当 g(n) = $\Theta$(f(n)) 6.4 转置对称性 f(n) = O(g(n)) 当且仅当 g(n) = Ω(f(n))f(n) = o(g(n)) 当且仅当 g(n) = ω(f(n)) 6.5 三分性&emsp;&emsp;对于任意两个数a、b，有三种情况必须成立：a &gt; b、a &lt; b、a = b。任意两个实数可以比较，但不是任意两个渐进函数都可以比较。对于g(n)与f(n)，f(n) = O(g(n))和f(n) = Ω(g(n))可能都不成立。例如n与n1+sin n，因为n1+sin n的幂值在0到2之间来回摆动。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法分析]]></title>
    <url>%2F2019%2F01%2F24%2F%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[算法分析 The analysis of algorithm is the theoretical study of computer program performance and resource usage算法分析是理论研究关于计算机程序性能和资源利用的研究。 &emsp;&emsp;这一句话是MIT公开课上Charles Leiserson第一节课对于算法分析的定义。学习算法是为了如何让计算机更快，也就是解决计算机的性能问题。当然，在目前软件工程领域来讲，性能已经不是第一位了，软件的可维护性、健壮性、安全性、可扩展性、模块化、用户友好性、更多的功能都非常重要。为什么很多人更加青睐于MacOS而非Windows？因为用户友好性以及安全性，在计算机发展史上，这是一个非常大的飞跃。&emsp;&emsp;但是，所有的这些事情看似都比性能重要，我们为什么要学算法？ 1.性能与用户体验是紧密联系的。 &emsp;&emsp;打开一个应用需要等半天是不会有什么用户体验的，即便界面再漂亮也没有用。所以性能达不到需求，用户体验很难保证。 2.性能直接决定了可行与不可行。 &emsp;&emsp;程序太慢或者程序占用内存太大会直接导致程序在一些机器上不可行。 3.算法是描述程序行为的一种语言。 &emsp;&emsp;这是一门被计算机学科广泛使用的语言，已经被所欧的实践者所采用的理论语言，是程序的思考方式。Charles Leiserson用一个很有趣的例子去描述了性能为什么处于最底层。他把性能比做经济中的货币，而可维护性、用户体验是食物和水，虽然食物和水对于生命来说比金钱更重要，但他们都需要货币去换取，性能是他们的保障。这就是为什么那么多人用Java去写程序而非C，尽管前者比后者多耗费了三倍的性能，因为Java的良好特性值得人们去付出这些代价，在这里，性能就被充当为了货币去获取其他的对象，这就是性能处于底层的原因。 4.很有趣。 现在就从一个非常简单的排序问题引入算法分析。 排序问题&emsp;&emsp;这是一个很古老的问题，输入一组序列a1，a2……an。按需求后输出a1‘&lt;=a2‘&lt;=……&lt;=an‘。使得他们单调递增。 插入排序&emsp;&emsp;首先引入插入排序，插入排序的算法思想，数组从左到右将其中每一个元素依次设为key，key的左半部分是已经排序过的数组，每一次遍历就会将已排序部分增长一，而每一次循环将会把已排序数组的值一个一个向右移动，知道出现合适位置，并将key插入其中，所以这个排序称之为插入排序。下面是对《算法导论》中插入排序伪代码的C++实现。123456789101112void insertSort(int *a,int length)&#123; int key,i; for(int j=1;j&lt;length;j++)&#123;//从第二个开始遍历，直到最后一个 key=a[j];//标记当前需要插入的数 i=j-1;//i作为指针，遍历j之前的数 while(i&gt;=0&amp;&amp;a[i]&gt;key)&#123; //开始遍历，如果遍历到的数比key大，就把这个数向后移一位，知道循环完毕或者碰到比key小的数 a[i+1]=a[i]; i=i-1; &#125; a[i+1]=key;//将key插入 &#125; 这就是插入排序，现在我们对这个排序进行一个分析，首先关注运算时间问题。 1.输入本身 如果输入的数组本身有序，那么我们做的事将会很少，但是最坏情况下，也就是逆序情况下，我们将会得到最坏对运行时间。 2.输入规模 我们在输入几个元素的情况下，这个算法很快，但是如果输入几十亿个元素对话，就需要很长时间，所以输入规模越大，运行时间越长。 3.运行时间上界 这代表对用户的承诺，就是是说保证这个程序运行不会超过某个时间，相反的，要说说这个程序运行至少多长时间，这种信息就不能被当作承诺。 算法分析平均情况分析&emsp;&emsp;有些情况下会这么做，在这里T(n)就是输入规模为n下所有可能输入的期望时间，也就是概率论中所说的E(x)，但是我们需要一个输入统计的分布假设，否则期望就无从谈起，最常见的是均匀分布。 最好情况分析&emsp;&emsp;一般被称为假象，因为最好情况基本很少出现，即使出现也是仅仅针对于少量情况适用，比如对一个已排好序的数组排序，但是不包含大量其他情况。 最坏情况分析&emsp;&emsp;这是我们通常最关注的问题，我们首先设T(n)为输入规模为n时的最长运行时间，只有做最坏的打算，我们才能对我们的程序进行承诺。&emsp;&emsp;先看一下插入排序的最坏时间。 首先取决于运行他的计算机。 一般比较算法比较的是他的相对运算速度也就是同一台机子上的运行速度，所以这个一般不考虑。我们需要计算机的大局观，一种观点，就是渐进分析。 渐进分析&emsp;&emsp;渐进分析的思路是忽略掉那些依赖于机器的常量，以及不是去检查实际的运行时间，而是关注运行时间增长。&emsp;&emsp;首先采用渐进符号$\Theta$。 弃去公式的低阶项，并忽略前面的常数因子，如果公式是3n3+90n2-5n+6046,那么这个公式可以说是$\Theta$(n3)。 当n趋近于无穷大时，$\Theta$(n2)肯定比$\Theta$(n3)快，无论其他项是什么也动摇不了这个结果，即使在一台慢速计算机运行$\Theta$(n2)，在一台高速计算机运行$\Theta$(n3)。但是这两个函数相交于一个n0点，如果这个n0过大，计算机就无法计算，所以某些时候会青睐一些低速算法，尽管从渐进角度看，他们会比较慢，但在合理输入情况下他们可能会更快。&emsp;&emsp;继续分析插入排序，在逆向排序好的情况下，插入排序需要将所有项全部翻一遍，假设每一个操作耗费一个原子时间，循环中所有的操作都是原子时间，所以在上面的算法中，j从1循环到length，我们可以写成数学中的求和符号，从1到length,设length为n,对于一个给定的j值，循环将会进行$\Theta$(j)次操作，因为内层循环里的i以j-1为初值，在i每次取新值时进行固定数量的操作，i从j-1降到0。 T(n)=$\sum_{j=1}^n$$\Theta$(j)=$\Theta$(n2)连续整数求和，算术级数 对于很小的n，插入排序很快，但对于巨大的n，就不行了，我们需要一个更快的算法————归并排序。 归并排序&emsp;&emsp;首先对于数组A[1……n] 1.如果n为1，那么数组就是排好序的。2.递归递归的对A[1到n/2向上取整]的这一部分，以及A[n/2+1向上取整到n]这部分排序3.把排好序的两个表归并 归并过程如图所示实质上就是将两个已排序好对的数组，也就是A[1..N/2]和A[N/2+1..n]，进行归并，得到一个排序好的数组，每一步都是固定的操作与数组长度无关，所以对于总数为n的输入，时间是$\Theta$(n)的。&emsp;&emsp;对于这个递归，我们可以写出一个递推式。 $$T(n) =\begin{cases} Θ(1)&amp;n=1\ 2T(n/2)+ Θ(n)&amp;n&gt;1 \end{cases}$$ &emsp;&emsp;这是一个树状结构，树的末端时间只有$\Theta$(1)，而树的高度是lgn，叶的节点总数为n，完全扩展的递归树有lgn+1层，每层贡献总代价$\Theta$(n)，如果计算总数就是$\Theta$(n)lgn+$\Theta$(n)，根据渐进的思想，最后结果就是$\Theta$(nlgn)，考虑渐进，他比$\Theta$(n2)快,在数据足够大的情况下，归并排序将优于插入排序，差不多n大于30归并就更快了。下面是对《算法导论》中归并排序的C++实现。1234567891011121314151617181920212223242526272829303132333435const int N=204800;void Merge(int *arr,int p,int q,int r)&#123; int n1=q-p+1;//左数组长度 int n2=r-q;//右数组长度 int left[n1+1],right[n2+1];//开辟新的左右数组 for(int i = 0; i !=n1; ++i)&#123; left[i]=arr[p+i];//为左数组赋值 &#125; left[n1]=N;//左数组“哨兵” for(int j = 0; j!= n2; ++j) &#123; right[j]=arr[q+j+1];//为右数组赋值 &#125; right[n2]=N;//右数组“哨兵” int i=0,j=0; for(int k = p; k !=r+1; ++k)//将左右数组归并至原数组 &#123; if(left[i]&gt;right[j])&#123; arr[k]=right[j]; ++j; &#125;else&#123; arr[k]=left[i]; ++i; &#125; &#125;&#125;void MergeSort(int *arr,int p,int r)&#123; //分治法，将数组分割，将复杂问题化简为数个简单问题 if(p&lt;r)&#123; int q=(p+r)/2;//数组分割标记，中间下标 MergeSort(arr,p,q);//分割左边数组 MergeSort(arr,q+1,r);//分割右边数组 Merge(arr,p,q,r);//进行归并排序 &#125;&#125; 这就是算法分析的一部分，后面还有更多的分析方法，如果想知道更多的证明细节，详见《算法导论》。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot-使用QueryDSL查询框架]]></title>
    <url>%2F2019%2F01%2F22%2FSpringBoot-%E4%BD%BF%E7%94%A8QueryDSL%E6%9F%A5%E8%AF%A2%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[SpringBoot-使用QueryDSL查询框架(基础) QueryDSL是一个通用的查询框架，框架的核心原则是创建安全类型的查询，开始QueryDSL仅支持Hibernate（HQL），在不断开源人士加入QueryDSL团队后，陆续发布了针对JPA，JDO，JDBC，Lucene，Hibernate Search，MangoDB，Collections 和RDF(Relational Data Format) Bean等。 简述&emsp;&emsp;在使用SpringDataJPA的时候，内置的QueryByExampleExecutor对复杂查询来说显然不怎么好用，于是在这里引入一个便于我们进行复杂查询的框架————QueryDSL。这个框架可以完美的和SpringDataJPA进行融合，接下来主要说怎么用。 项目构建&emsp;&emsp;怎么搭建SpringBoot、数据源、数据库连接、配置SpringDataJPA就不说了，在原先的基础上添加项目依赖。12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;com.querydsl&lt;/groupId&gt; &lt;artifactId&gt;querydsl-jpa&lt;/artifactId&gt; &lt;version&gt;4.0.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.querydsl&lt;/groupId&gt; &lt;artifactId&gt;querydsl-apt&lt;/artifactId&gt; &lt;version&gt;4.2.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.inject&lt;/groupId&gt; &lt;artifactId&gt;javax.inject&lt;/artifactId&gt; &lt;version&gt;1&lt;/version&gt;&lt;/dependency&gt; 仅仅添加依赖还不够，我们需要在下面的&lt;plugins&gt;标签中添加插件 1234567891011121314151617&lt;!--该插件生成查询对象--&gt; &lt;plugin&gt; &lt;groupId&gt;com.mysema.maven&lt;/groupId&gt; &lt;artifactId&gt;apt-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.1.3&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;process&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;outputDirectory&gt;target/generated-sources/java&lt;/outputDirectory&gt; &lt;processor&gt;com.querydsl.apt.jpa.JPAAnnotationProcessor&lt;/processor&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; 然后在idea界面右上角打开Edit Configurations,新建一个maven，填入如图所示信息。在右上角启动这个插件。该插件会自动扫描项目内配置了@Entity的实体类，并根据实体的内定义的字段以及关联类通过JPAAnnotationProcessor自动创建Q[实体类名称]的查询实体，创建完成后会将实体存放到我们配置outputDirectory属性目录下。如图所示。 准备准备数据库信息&emsp;&emsp;先构建一个普通的User实体类,项目启动时会自动根据这个实体类建表，建表后向里面扔几条测试数据。123456789101112131415161718192021/** * @Author: cp * @Date: 2019/1/21 下午11:13 * @Version 1.0 */@Entity@Table(name = "user")public class User implements Serializable &#123; @Id @Column(name = "id") @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; @Column(name = "name") private String name; @Column(name = "age") private String age; @Column(name = "address") private String address; @Column(name = "pwd") private String pwd; /*setter and getter*/ 创建基类JPA&emsp;&emsp;正如上一篇所说，正常情况下一个项目肯定不可能就继承一个JpaRepository接口，再使用其他模块时还需要多个接口继承，如果每一个业务数据接口都继承几个相同的接口的话，对于系统设计和代码复用性来说不是个什么好的选择。所以我们需要一个基类JPA。12345678/** * @Author: cp * @Date: 2019/1/21 下午11:16 * @Version 1.0 */@NoRepositoryBeanpublic interface BaseJPA&lt;T&gt; extends JpaRepository&lt;T,Integer&gt;,JpaSpecificationExecutor&lt;T&gt;,QuerydslPredicateExecutor&lt;T&gt; &#123;&#125; @NoRepositoryBean是为了避免自动实例化。 创建对应模块JPA&emsp;&emsp;创建对应User模块的数据逻辑接口JPA，因为BaseJPA已经继承了我们所需要的所有接口，所以我们只需要继承BaseJPA就可以了。1234567/** * @Author: cp * @Date: 2019/1/21 下午11:18 * @Version 1.0 */public interface UserJPA extends BaseJPA&lt;User&gt; &#123;&#125; 执行插件生成Q结构查询实体&emsp;&emsp;这个不多说了，刚才生成过了。打开自动创建的实体后可以看到QueryDSL自动为我们创建的查询字段以及构造函数。 编写控制器&emsp;&emsp;为了方便我就不写Service层了，所有业务逻辑全部放在Controller层，不过正式开发时一定要写。12345678910111213141516/** * @Author: cp * @Date: 2019/1/21 下午11:20 * @Version 1.0 */@RestControllerpublic class UserController &#123; @Autowired private UserJPA userJPA; @Autowired private EntityManager entityManager; private JPAQueryFactory queryFactory; @PostConstruct public void initFactory()&#123; queryFactory=new JPAQueryFactory(entityManager); &#125; 声明EntityManager的注入以及JPAQueryFactory工厂对象的创建，通过@PostConstruct注解在类初始化的时候完成对JPAQueryFactory对象的实例化。 查询查询并排序12345678@RequestMapping(value = "/queryAll")public List&lt;User&gt; queryAll()&#123; QUser qUser=QUser.user;//创建查询对象 return queryFactory//查询并返回 .selectFrom(qUser)//源 .orderBy(qUser.id.desc())//根据id倒序 .fetch();//执行并返回结果集&#125; &emsp;&emsp;queryAll方法内首先获取了对应UserBean的查询实体QUserBean，通过QUserBean内自动生成的字段获取，我们使用JPAQueryFactory工厂对象的selectFrom方法来简化查询，该方法代替了select&amp;from两个方法，注意：也是仅限单表操作时可以使用。&emsp;&emsp;这样写起来感觉就像在写原生SQL，在一系列的条件都添加完成后，调用fetch方法执行我们的条件查询并且获取对应selectFrom查询实体的类型集合，要注意一点：这里如果selectFrom参数的实体类型不是User那fetch方法返回集合的类型也不是List&lt;User&gt;。&emsp;&emsp;启动后访问这个方法就可以在网页中见到这些数据，同时在控制台中也可以看见生成的SQL语句。1234567891011Hibernate: select user0_.id as id1_3_, user0_.address as address2_3_, user0_.age as age3_3_, user0_.name as name4_3_, user0_.pwd as pwd5_3_ from user user0_ order by user0_.id desc 根据主键查询数据&emsp;&emsp;这个方法是最常用的方法，现在我们有两种写法，一种是使用QueryDSL，另外一种是和SpringDataJPA结合。使用QueryDSL：12345678@RequestMapping(value = "/detail/&#123;id&#125;")public User detail(@PathVariable("id") Integer id)&#123; QUser qUser=QUser.user;//使用querydsl return queryFactory .selectFrom(qUser)//源 .where(qUser.id.eq(id))//条件 .fetchOne();//结果&#125; SpringDataJPA+QueryDSL:12345@RequestMapping(value = "/detail_2/&#123;id&#125;") public Optional&lt;User&gt; detail_2(@PathVariable("id") Integer id)&#123; QUser qUser=QUser.user;//使用querydsl return userJPA.findOne(qUser.id.eq(id));//查询并返回结果 &#125; 网上的一些教程关于SpringDataJPA+QueryDSL的方法返回值好多都是直接返回实体类，不过最新的方法已经修改为返回Optional类，用来解决万恶的空指针异常。&emsp;&emsp;这两种代码效果是一样的，都是根据主键返回对应信息，看起来SpringDataJPA+QueryDSL还简单一点，不过这只限于单表查询，一旦涉及各种复杂操作还是QueryDSL简单。在使用QueryDSL查询指定主键时，我们使用了where方法并且指定了id字段需要eq参数id，这个eq是QueryDSL内置的一个方法，用于查询指定值数据，当然其他字段也同样可以使用eq方法来完成条件查询，都是可以变通使用的。 模糊查询&emsp;&emsp;根据name字段模糊查询。12345678@RequestMapping(value = "like")public List&lt;User&gt; likeQueryByName(String name)&#123; QUser qUser=QUser.user;//使用querydsl return queryFactory .selectFrom(qUser)//源 .where(qUser.name.like("%"+name+"%"))//条件 .fetch();&#125; like是QueryDSL内置方法，只要存入条件，就可以完成模糊查询，可以看一下控制台输出的SQL语句。1234567891011Hibernate: select user0_.id as id1_3_, user0_.address as address2_3_, user0_.age as age3_3_, user0_.name as name4_3_, user0_.pwd as pwd5_3_ from user user0_ where user0_.name like ? escape '!' 更新使用SpringDataJPA更新实体&emsp;&emsp;与Hibernate一样，SpringDataJPA内置了一个save方法用于保存、更新实体内容，如果存在主键值则更新对应信息，反则是添加一条新信息。我们新添加一个方法。12345678910@RequestMapping(value = "/updateJPA")public String updateJPA()&#123; User user=new User(); user.setId(1); user.setName("王五"); user.setAge("13"); user.setPwd("321"); userJPA.save(user); return "success";&#125; 很简单，并没有什么难理解的地方，直接访问这个方法就可以看结果了，重点是先看控制台输出的SQL语句，首先输出了一条查询语句。12345678910select user0_.id as id1_3_0_, user0_.address as address2_3_0_, user0_.age as age3_3_0_, user0_.name as name4_3_0_, user0_.pwd as pwd5_3_0_ from user user0_ where user0_.id=? 这是因为SpringDataJPA先去查询数据库中有没有这个主键的信息，如果有，才会执行下面的更新语句。123456789update user set address=?, age=?, name=?, pwd=? where id=? 使用QueryDsl更新实体1234567891011121314151617181920@Transactional@RequestMapping(value = "updateDsl")public String updateByQueryDsl()&#123; User user=new User(); user.setPwd("090"); user.setAge("80"); user.setName("赵四"); user.setId(1); user.setAddress("北京"); QUser qUser=QUser.user; queryFactory .update(qUser) .set(qUser.name,user.getName()) .set(qUser.address,user.getAddress()) .set(qUser.age,user.getAge()) .set(qUser.pwd,user.getPwd()) .where(qUser.id.eq(user.getId())) .execute(); return "SUCCESS";&#125; &emsp;&emsp;与SpringDataJPA不同的是，使用save方法的时候，如果实体类中某一条是空的，那么数据库中对应字段也会被设为空，而使用QueryDsl时就可以随心所欲的选择只更新某几条信息。设置完成更新字段后需要设置更新的条件，不设置也是可以的，当然这里肯定跟原生SQL一样，不设置条件就更新表内全部的数据。最后使用execute()执行操作就行了。 敲黑板：在执行update/delete方法时必须添加事务，也就是@Transactional注解，否则会抛出异常。 这是控制台输出的语句。12345678910Hibernate: update user set name=?, address=?, age=?, pwd=? where id=? 删除使用SpringDataJPA删除实体信息1234567@RequestMapping(value = "/deletejpa")public String deletejpa()&#123; User user=new User(); user.setId(4); userJPA.deleteById(user.getId());//删除指定主键的值 return "success";&#125; &emsp;&emsp;简单粗暴，不用解释。 使用QueryDsl删除实体信息123456789101112@Transactional//这个必须有@RequestMapping(value = "/deletequery")public String deleteQueryDsl()&#123; User user=new User(); user.setId(4); QUser qUser=QUser.user; queryFactory .delete(qUser)//删除 .where(qUser.id.eq(user.getId()))//条件 .execute();//执行 return "sueecss";&#125; &emsp;&emsp;跟update方法差不多，就是把update改成delete，看起来好像比SpringDataJPA还麻烦了，但是我们引入这个框架是为了复杂查询，所以我们加一个限定条件，删除id大于四，且name值为王五的人。123456789101112131415@Transactional//这个必须有@RequestMapping(value = "/deletequeryid")public String deletequeryById()&#123; User user=new User(); user.setName("mvm"); QUser qUser=QUser.user; queryFactory .delete(qUser)//删除 .where( qUser.name.eq(user.getName()) .and(qUser.id.gt(4))//条件 ) .execute();//执行 return "success";&#125; SpringDataJPA想要完成这个就没那么简单了，看一下生成的SQL语句。1234567Hibernate: delete from user where name=? and id&gt;? 还是很规范的，输出的SQL完全根据我们设置的条件来自动生成，QueryDsl内的条件可以跟原生SQL完全一样，可以完全采用SQL的思想来编写条件。 最后&emsp;&emsp;以上是SpringDataJPA结合QueryDSL的基础操作，后续还会继续学习多表关联查询、自定义返回对象、聚合查询、子查询等复杂操作。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>SpringDataJPA</tag>
        <tag>QueryDSL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot-整合SpringDataJPA]]></title>
    <url>%2F2019%2F01%2F21%2FSpringBoot-%E6%95%B4%E5%90%88SpringDataJPA%2F</url>
    <content type="text"><![CDATA[SpringBoot-整合SpringDataJPA1.简述&emsp;&emsp;SpringDataJPA是Spring Data的一个子项目，默认底层是Hibernate，使用基于JPA的Repository,极大的减少对数据库访问的代码量，仅仅使用内部接口就可以完成简单的crud操作。 2.搭建项目&emsp;&emsp;还使用之前搭好的框架进行测试，由于是测试，为了方便就不搭建Service层了，所有逻辑代码都放在了Controller层，数据源使用alibaba的Druid数据源，关于Druid以后慢慢说，不放在这里讨论。 2.1导入依赖并修改配置文件&emsp;&emsp;首先在pom.xml原来的基础中添加配置。123456789&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.12&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt; 然后修改配置文件，添加关于Druid和SpringBootJPA的依赖123456789101112131415161718192021222324252627282930313233343536spring: mvc: view: prefix: /WEB-INF/views/ suffix: .jsp datasource: type: com.alibaba.druid.pool.DruidDataSource url: jdbc:mysql://127.0.0.1:3306/test3?characterEncoding=UTF-8 username: root password: 20141232 driver-class-name: com.mysql.jdbc.Driver #最大活跃数 maxaActive: 20 #初始化数量 InitialSize: 1 #最大连接等待时间 maxWait: 60000 #打开PSCache，并指定大小 poolPreparedStatements: true maxPoolPreparedStatementPerConnectionSize: 20 minIdle: 1 connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: select 1 from dual testWhileIdle: true testOnBorrow: false testOnReturn: false filters: stat, wall, log4j jpa: properties: hibernate: hbm2ddl: auto: update show_sql: true format_sql: true 之后还需要在入口文件ZzuliApplication中添加两条注解。12345678@SpringBootApplication@EnableAutoConfiguration@ComponentScan(basePackages = &#123;"cn.edu.zzuli"&#125;)public class ZzuliApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ZzuliApplication.class, args); &#125;&#125; @EnableAutoConfiguration禁止掉多数据源的自动注入，如果不这样做就会产生maven的依赖包冲突，导致重复依赖。@ComponentScan会扫描指定包，在指定包中寻找带注解的类。 2.2 使用JpaRepository&emsp;&emsp;与Hibernate一样，都需要一个实体类对数据库表结构进行映射，在启动项目时，会对实体类创建相应的表结构。所以先在domain包里创建StudentEntity类，get和set方法在此省略了。1234567891011121314151617181920212223242526272829package cn.edu.zzuli.domain;import cn.edu.zzuli.base.BaseEntity;import javax.persistence.*;import java.io.Serializable;/** * @Author: cp * @Date: 2019/1/20 下午3:56 * @Version 1.0 */@Entity@Table(name = "studentEntity")public class StudentEntity implements Serializable &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = "s_id") private Integer id; @Column(name = "s_name") private String name; @Column(name = "s_age") private Integer age; @Column(name = "s_address") private String address; /*getter and setter*/&#125; 对这几个注解做一下说明，使用@Entity会对实体类进行持久化操作，当JPA检测到实体类中有@Entity注解时，会在数据库中生成对应的表结构信息。@Table用来指定表名，@Id用来指定主键，配合@GeneratedValue(strategy = GenerationType.IDENTITY)指定主键自增策略，这里将主键自增交给数据库去做，所以使用IDENTITY，@Column用来指定对应表中的字段名。&emsp;&emsp;之后我们需要创建StudentJPA接口,先创建一个jpa包，在下面创建StudentJPA接口，继承JpaRepository，需要两个参数，一个是实体类对象，一个是主键类型。1234567/** * @Author: cp * @Date: 2019/1/20 下午4:01 * @Version 1.0 */public interface StudentJPA extends JpaRepository&lt;StudentEntity,Integer&gt; &#123;&#125; 我们查看JpaRepository就可以看到这个接口又继承了PagingAndSortingRepository和QueryByExampleExecutor接口，PagingAndSortingRepository又继承了CrudRepository接口，浓浓的Spring风格，基本上看名字就知道这个接口大概是干什么的，至于为什么这么设计，那就是架构的问题了。 2.1.1 CrudRepository&emsp;&emsp;看名字就知道，这个接口中包含了crud操作，也就是creat、select、delete、update、exist、count.1234567891011121314@NoRepositoryBeanpublic interface CrudRepository&lt;T, ID&gt; extends Repository&lt;T, ID&gt; &#123; &lt;S extends T&gt; S save(S var1); &lt;S extends T&gt; Iterable&lt;S&gt; saveAll(Iterable&lt;S&gt; var1); Optional&lt;T&gt; findById(ID var1); boolean existsById(ID var1); Iterable&lt;T&gt; findAll(); Iterable&lt;T&gt; findAllById(Iterable&lt;ID&gt; var1); long count(); void deleteById(ID var1); void delete(T var1); void deleteAll(Iterable&lt;? extends T&gt; var1); void deleteAll();&#125; 如果继承该接口就会拥有所有该接口的实现。 2.1.2 PagingAndSortingRepository&emsp;&emsp;顾名思义，分页和排序，而且继承了CrudRepository接口，拥有其所有的接口实现。12345@NoRepositoryBeanpublic interface PagingAndSortingRepository&lt;T, ID&gt; extends CrudRepository&lt;T, ID&gt; &#123; Iterable&lt;T&gt; findAll(Sort var1); Page&lt;T&gt; findAll(Pageable var1);&#125; 2.1.3 QueryByExampleExecutor&emsp;&emsp;这个接口就是实现条件查询和复杂查询的，可以使用exmple的方式查询。12345678public interface QueryByExampleExecutor&lt;T&gt; &#123; &lt;S extends T&gt; Optional&lt;S&gt; findOne(Example&lt;S&gt; var1); &lt;S extends T&gt; Iterable&lt;S&gt; findAll(Example&lt;S&gt; var1); &lt;S extends T&gt; Iterable&lt;S&gt; findAll(Example&lt;S&gt; var1, Sort var2); &lt;S extends T&gt; Page&lt;S&gt; findAll(Example&lt;S&gt; var1, Pageable var2); &lt;S extends T&gt; long count(Example&lt;S&gt; var1); &lt;S extends T&gt; boolean exists(Example&lt;S&gt; var1);&#125; 但是我感觉这个东西不怎么好用，以后会有替代品。 2.1.4 JpaRepository&emsp;&emsp;我们用的就是这个接口，它拥有以上所有接口的方法实现，并添加了条件查询和保存集合数据的方法，基本上简单的数据库操作就不需要写SQL了。1234567891011121314@NoRepositoryBeanpublic interface JpaRepository&lt;T, ID&gt; extends PagingAndSortingRepository&lt;T, ID&gt;, QueryByExampleExecutor&lt;T&gt; &#123; List&lt;T&gt; findAll(); List&lt;T&gt; findAll(Sort var1); List&lt;T&gt; findAllById(Iterable&lt;ID&gt; var1); &lt;S extends T&gt; List&lt;S&gt; saveAll(Iterable&lt;S&gt; var1); void flush(); &lt;S extends T&gt; S saveAndFlush(S var1); void deleteInBatch(Iterable&lt;T&gt; var1); void deleteAllInBatch(); T getOne(ID var1); &lt;S extends T&gt; List&lt;S&gt; findAll(Example&lt;S&gt; var1); &lt;S extends T&gt; List&lt;S&gt; findAll(Example&lt;S&gt; var1, Sort var2);&#125; 3.测试3.1 创建Controller层&emsp;&emsp;在controller 包中新建JPAStudentController类，这回测试就不使用JSP了，直接带上@RestController注解，并注入StudentJPA，返回json格式验证数据。12345678910/** * @Author: cp * @Date: 2019/1/20 下午4:06 * @Version 1.0 */@RestControllerpublic class JPAStudentController &#123; @Autowired private StudentJPA studentJPA;&#125; 3.2开启测试3.1.1 查询&emsp;&emsp;在JPAStudentController中添加list方法，使用JpaRepository内部实现的findAll方法。1234@RequestMapping(value = "/stu")public List&lt;StudentEntity&gt; list() &#123; return studentJPA.findAll();&#125; 接着在浏览器访问访问localhost:8080/stu，可以看到页面返回的数据。可以看到我在数据库预先准备的数据。&emsp;&emsp;除此之外，只要继承JpaRepository接口，我们还能使用方法规则进行查询，我第一次见的时候感觉挺神奇的，举个栗子，我在StudentJPA中定义StudentEntity findByName(String name);方法，他就可以直接被解析为。1select from StudentEntity where name=? 超级方便，简单的查询直接写定义这么一个方法就好了，不过弊端就是对于复杂查询，方法名会超级长，而且很难实现。&emsp;&emsp;如果想对SQL语句进行细致优化的话，我们还可以使用@Query注解自定义SQL。打开StudentJPA，在其中添加以年龄为条件的查询。12@Query(value = "select * from student_entity where s_age&gt;=?",nativeQuery = true)public List&lt;StudentEntity&gt; SelectByAge(int age); nativeQuery这个设置为true表明使用原生SQL，否则默认启用HQL。在controller层添加代码。1234@RequestMapping(value = "/age")public List&lt;StudentEntity&gt; age()&#123; return studentJPA.SelectByAge(20);&#125; 重启项目并在浏览器中输入localhost:8080/age。 3.1.2 增加&emsp;&emsp;增加数据只需要将实体类当作参数，调用StudentJPA的save方法即可。123456789@RequestMapping(value = "/add") public String add()&#123; StudentEntity entity=new StudentEntity(); entity.setAddress("郑州轻工业大学"); entity.setAge(19); entity.setName("范秉洋"); studentJPA.save(entity); return "添加成功"; &#125; save方法不仅仅用于增加，如果实体类中传入主键，那么save方法就会变为根据主键更新数据库操作，下面就不再写更新的方法了。 3.1.3 删除&emsp;&emsp;直接使用JpaRepository提供的deleteById方法即可。12345@RequestMapping(value = "/delete")public String delete(Integer userId)&#123; studentJPA.deleteById(userId); return "删除成功";&#125; 3.1.4 自定义语句&emsp;&emsp;如同在查询中使用@Query注解一样，增删改查都可以使用原生SQL对数据库操作，不过@Query只能查询，那么就需要配合另一个注解@Modifying一起使用。创建一个根据姓名和年龄删除数据的方法。123@Modifying@Query(value = "delete from student_entity where s_name=? and s_age=?",nativeQuery = true)public void deleteQuery(String name,Integer age); 如果这么写的话，会抛出一个TranscationRequiredException异常，意思就是当前操作需要事务，所以要在这个方法前加@Transactional开启自动化管理。 3.1.5 自定义BaseRepository&emsp;&emsp;正常情况下一个项目肯定不可能就继承一个JpaRepository接口，再使用其他模块时还需要多个接口继承，如果每一个业务数据接口都继承几个相同的接口的话，不是不可以，但是对于系统设计和代码复用性来说不是个什么好的选择。&emsp;&emsp;创建一个叫base的包，在里面添加BaseRepository接口，并继承JpaRepository。12345678/** * @Author: cp * @Date: 2019/1/20 下午10:29 * @Version 1.0 */@NoRepositoryBeanpublic interface BaseRepository&lt;T,PK extends Serializable&gt; extends JpaRepository&lt;T,PK&gt; &#123;&#125; @NoRepositoryBean:这个注解如果配置在继承了JpaRepository接口以及其他SpringDataJpa内部的接口的子接口时，子接口不被作为一个Repository创建代理实现类。 以后再创建接口继承BaseRepository就行了，他有JpaRepository所有实现方法。 3.1.6 分页查询&emsp;&emsp;对于一般项目来说分页是少不了的，当然，SpringDataJPA也内置了分页方法。&emsp;&emsp;先创建一个BaseEntity，添加几个字段：当前页码、每页条数、排序列，排序方法。12345678910111213141516171819202122232425/** * @Author: cp * @Date: 2019/1/20 下午10:45 * @Version 1.0 */public class BaseEntity &#123; /** * 默认页码 */ protected int page=1; /** * 默认分页数量 */ protected int size=2; /** * 排序列名为id */ protected String sidx="id"; /** * 排序规则 * @return */ protected String sord="desc"; /*getter and setter*/&#125; 修改StudentEntity类继承BaseEntity,由于数据不多，所以设定一页就两条。在JPAStudentController中添加cut方法，并添加对应分页逻辑。注意在分页中页码是从0开始的。1234567@RequestMapping(value = "/page") public List&lt;StudentEntity&gt; Page(Integer page)&#123; StudentEntity entity=new StudentEntity(); entity.setSize(2); entity.setPage(page); return studentJPA.findAll(PageRequest.of(entity.getPage()-1,entity.getSize())).getContent(); &#125; 从网上找的分页方法是使用PageRequest对象，不过使用时发现这个方法的构造方法在最新版本中被废弃了，查看源码后得知取而代之的是静态的PageRequest.of()方法。接下来重启项目并访问该方法。 3.1.6 排序&emsp;&emsp;BaseEntity预设好了对应字段，所以重新编辑page方法，将Sort对象添加在PageRequest.of()中就可以实现排序。12345678910111213@RequestMapping(value = "/page") public List&lt;StudentEntity&gt; Page(Integer page)&#123; StudentEntity entity=new StudentEntity(); entity.setSize(2); entity.setPage(page); entity.setSord("desc"); //获取排序对象 Sort.Direction sort_Direction=Sort.Direction.ASC.toString().equalsIgnoreCase(entity.getSord())?Sort.Direction.ASC:Sort.Direction.DESC; //设置排序对象 Sort sort=new Sort(sort_Direction,entity.getSidx()); //执行分页 return studentJPA.findAll(PageRequest.of(entity.getPage()-1,entity.getSize(),sort)).getContent(); &#125; 我们现在将顺序按照id倒序排序，SpringDataJPA对排序方式添加了一个枚举类型，创建Sort对象时也需要枚举对象，因为我们BaseEntity配置的是字符串所以上面多了一步判断排序方式返回枚举对象。重启项目。 4.总结&emsp;&emsp;基本操作就这么多了，包括了：CURD、分页、排序、自定义SQL、定义BaseRepository、事务处理等。用起来还是挺方便的，但是这并不是全部，后面还会对一对多、多对多等复杂查询进行总结，今天就先到这里吧。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>SpringDataJPA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot-快速搭建]]></title>
    <url>%2F2019%2F01%2F19%2FSpringBoot-%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[SpringBoot-快速搭建1.SpringBoot简述 Spring Boot makes it easy to create stand-alone production-grade Spring based Applications that you can “just run”.We take an opinionated view of the Spring platform and third-party libraries so you can get started with minimum fuss. Most Spring Boot applications need very little Spring configuration. &emsp;&emsp;摘自官网,大致意思是创建独立的、快速的、生产级的基于Spring的应用，对Spring和第三方库进行整合，轻松上手，只需要很少的配置就可以使用。 1.1优势&emsp;&emsp;在之前使用SSH(都9102年了我估计也没多少人用Struts了吧)与SSM时，虽然相对于传统的JSP+servlet+jdbc的开发模式简化了开发流程，但是在项目初期搭建的时候相当繁琐，大致需要： 1.配置xml，加载一坨配置文件. 2.配置Spring和SpringMVC，这两个还好，可以写到一个里面，配置Struts那是相当难受. 3.配置数据源，配置日志文件. 4.配置Mybatis的Mapper文件和Hibernate的配置文件 5.各种动态扫描注解 …… &emsp;&emsp;如果是在我学Django之前,我还是可以忍受这种东西的，但是学完Django之后，这种繁琐的配置就让人觉得很难受，我一直期望着Java中有一个和Django一样一个框架就可以干完所有活而且配置还非常简单的框架。得益于我喜欢在知(bi)乎上瞎逛，我了解了SpringBoot相关的技术链，并在禹州实训期间闲的没事干的情况下蹦入了这个坑，试了之后就一个字————爽！&emsp;&emsp;基本全程就几个配置文件，而且都不是xml，所有配置都是自动配置的，而且它内置tomcat，在使用idea的情况下，idea内置的各种工具可以实现全部框架的自动生成，再这里吹一波JetBrain。 突出优势：简单、快速、方便的搭建项目主流开发框架无配置集成提高开发、部署效率 2.项目搭建2.1开发环境 os:MacOS 10.13.4 ide:IDEA 2018.1.4 jdk:10.0.1 maven:3.3.9 tomcat:9.0(框架自带) 2.2新建项目&emsp;&emsp;新建项目时，点击左侧的Spring Initializr,然后点击next。 &emsp;&emsp;下一个页面是修改项目信息，第一个参数Group的域，第二个参数Artifact一般代表公司名称，这两个参数都是提供给maven的。最后一个参数Package为项目总包名，余下几个参数，Type一般都选择maven，Languge一般选择Java，也可以使用其他虚拟机语言，比如Kotlin、Groovy。Packing是打包方式，可以选择打成jar包或者war包 钩上web模版选择位置&emsp;&emsp;因为依托与maven，第一次加载时间可能比较长，因为所有配置需要从网络上去拉取，下载完毕后文件目录如图所示。看一下目录，大致分为三块： java文件：代码源文件，逻辑代码都在这里，里面那个ZzuliApplicaion是系统入口文件。 resource文件：静态资源文件，里面放着所有的静态资源和配置文件，application.properties中可以添加其他配置。 test文件：测试模块，里面内涵一个Junit测试。 外面有一个pom.xml文件，这个是maven的配置文件。 2.3 测试运行&emsp;&emsp;在之前创建的cn.edu.zzuli文件夹下创建Controller文件夹，并创建HelloWorldController类进行测试。1234567891011121314151617package cn.edu.zzuli.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;/** * @Author: cp * @Date: 2019/1/19 下午4:38 * @Version 1.0 */@RestControllerpublic class HelloWorldController &#123; @RequestMapping("/php") public String php()&#123; return "php是世界上最好的语言"; &#125;&#125; 基本上还是和SpringMVC很像的，唯一一点不同就是@RestController注解，这个注解就是原来@Controller和@ResponseBody注解的合体版。&emsp;&emsp;直接点击右上角的箭头或者启动ZzuliApplicaion类。出现这个界面就说明SpringBoot启动成功了。接着在浏览器中直接访问http://localhost:8080/php信息已被返回。 3.分析项目3.1 pox.xml文件&emsp;&emsp;SpringBoot自动生成的pox.xml文件如下12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.2.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;cn.edu&lt;/groupId&gt; &lt;artifactId&gt;zzuli&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;zzuli&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 相较于一般的pox.xml文件，这里多了一个&lt;parent&gt;标签,这个标签是在配置SpringBoot的父级依赖,有了这个，当前的项目才是SpringBoot项目，spring-boot-starter-parent是一个特殊的starter，它用来提供相关的maven默认依赖，使用它之后，常用的包依赖就可以省去version标签。&emsp;&emsp;\repository\org\springframework\boot\spring-boot-dependencies\2.0.1.RELEASE\spring-boot-dependencies-2.0.1.RELEASE.pom里面有SpringBoot的所有依赖，想了解的去这里看看 3.2 入口类&emsp;&emsp;SpringBoot项目通常有一个名为*Application的入口类，入口类里有一个main方法，这个main方法其实就是一个标准的Java应用的入口方法。&emsp;&emsp;@SpringBootApplication是SpringBoot的核心注解，它是一个组合注解，该注解组合了：@Configuration、@EnableAutoConfiguration、@ComponentScan若不是用@SpringBootApplication注解也可以使用这三个注解代替。&emsp;&emsp;其中，EnableAutoConfiguration让SpringBoot根据类路径中的jar包依赖为当前项目进行自动配置，例如，添加了spring-boot-starter-web依赖，会自动添加Tomcat和SpringMVC的依赖，那么SpringBoot会对Tomcat和SpringMVC进行自动配置。&emsp;&emsp;SpringBoot还会自动扫描@SpringBootApplication所在类的同级包以及下级包里的Bean，所以入口类建议就配置在grounpID+arctifactID组合的包名下（这里为cn.edu.zzuli包），使用idea自动创建项目的话idea会自动在这里创建。 3.3 配置文件&emsp;&emsp;SpringBoot使用一个全局的配置文件application.properties或application.yml，放置在src/main/resources目录或者类路径的/config下。&emsp;&emsp;SpringBoot不仅支持常规的properties配置文件，还支持yaml语言的配置文件。yaml是以数据为中心的语言，在配置数据的时候具有面向对象的特征。&emsp;&emsp;SpringBoot的全局配置文件的作用是对一些默认配置的配置值进行修改。这里我将application.properties修改为application.yml。 4.使用SpringBoot&emsp;&emsp;上面只是一些简单的搭建以及运行，下面再深入了解一下SpringBoot的应用。SpringBoot的默认视图支持是 Thymeleaf 模板引擎。但是咱不会，只好还用JSP。 4.1集成JSP1.在pom.xml文件中集成JSP，向pom.xml中添加1234567891011121314&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 2.在application.yml文件配置视图解析器，将我们的 JSP 文件重定向到 /WEB-INF/views/ 目录下：12345spring: mvc: view: prefix: /WEB-INF/views/ suffix: .jsp 3.修改@RestController注解为@Controller，然后修改 php 方法： 12345678910111213/** * @Author: cp * @Date: 2019/1/19 下午4:38 * @Version 1.0 */@Controllerpublic class HelloWorldController &#123; @RequestMapping("/php") public String php(Model model)&#123; model.addAttribute("php","php是世界上最好的语言"); return "php"; &#125;&#125; 4.在src/main目录下依次创建webapp/WEB-INF/views目录，并创建一个 hello.jsp 文件： 123&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8" %&gt;谁是世界上最好的语言？&lt;br&gt;$&#123;php&#125; 再刷新页面就可以看到效果了。 4.2集成MyBatis1.在pox.xml中添加对mysql和mybatis对依赖123456789101112&lt;!-- mybatis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- mysql --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.21&lt;/version&gt;&lt;/dependency&gt; 2.在配置文件中添加配置12345678910111213spring: mvc: view: prefix: /WEB-INF/views/ suffix: .jsp datasource: url: jdbc:mysql://127.0.0.1:3306/test3?characterEncoding=UTF-8 username: root password: 20141232 driver-class-name: com.mysql.jdbc.Driver jpa: hibernate: ddl-auto: update 3.先在cn.edu.zzuli中创建domain包和mapper包，再创建Student实体类和StudentMapper映射类分别放入domain和mapper包,1234567891011121314151617181920212223242526272829package cn.edu.zzuli.domain;/** * @Author: cp * @Date: 2019/1/19 下午6:35 * @Version 1.0 */public class Student &#123; int id; String name; int age; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 123456789101112131415161718package cn.edu.zzuli.mapper;import cn.edu.zzuli.domain.Student;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Select;import java.util.List;/** * @Author: cp * @Date: 2019/1/19 下午6:41 * @Version 1.0 */@Mapperpublic interface StudentMapper &#123; @Select("select * from student") List&lt;Student&gt; findAll();&#125; 4.写一个StudentContorller 123456789101112131415161718192021222324252627package cn.edu.zzuli.Controller;import cn.edu.zzuli.domain.Student;import cn.edu.zzuli.mapper.StudentMapper;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import java.util.List;/** * @Author: cp * @Date: 2019/1/19 下午6:44 * @Version 1.0 */@Controllerpublic class StudentController &#123; @Autowired StudentMapper studentMapper; @RequestMapping("/studentlist") public String studentlist(Model model)&#123; List&lt;Student&gt; students=studentMapper.findAll(); model.addAttribute("list",students); return "list"; &#125;&#125; 5.写一个list.jsp文件 1234567891011121314151617&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%&gt;&lt;table align='center' border='1' cellspacing='0'&gt; &lt;tr&gt; &lt;td&gt;id&lt;/td&gt; &lt;td&gt;name&lt;/td&gt; &lt;/tr&gt; &lt;c:forEach items="$&#123;list&#125;" var="s" varStatus="st"&gt; &lt;tr&gt; &lt;td&gt;$&#123;s.id&#125;&lt;/td&gt; &lt;td&gt;$&#123;s.name&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt;&lt;/table&gt; 刷新网络，大功告成。 以上就是springboot的搭建，随后的时间里会对Springboot的其他模块进行更深入的探索。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F01%2F17%2Fhello-world%2F</url>
    <content type="text"><![CDATA[我的第一篇博客]]></content>
  </entry>
</search>
