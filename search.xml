<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[mongodb安装]]></title>
    <url>%2F2019%2F02%2F05%2Fmongodb%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[mongodb安装&emsp;&emsp;大年初一无聊，玩玩mongodb。 写在前面&emsp;&emsp;再知乎上经常听到大名鼎鼎的nosql类型数据库，相对于关系型数据库来说，这个东西部署很简单，储存方式为虚拟内存+持久化存储，总结起来一个字————快。nosql存起来是key-value形式的，也支持集合和对象但是并不支持事务，也不能连表查询。&emsp;&emsp;传统的数据库体系非常成熟，可以进行事务操作，能用SQL语句进行复杂操作，不过当数据量极大时，关系型数据库效率会大打折扣，我猜一个很大的原因是外键的关系，查询中一系列组合索引会消耗很长时间，好多公司会针对这种情况进行分库分表，阿里巴巴开发手册里也说明尽量不要使用外键，将所有的关联事务在服务层解决。But，这种情况我从来没遇见过，我这种小菜鸡目前写的东西是肯定没有这么多用户的，这些都是我听说的。&emsp;&emsp;而内存级数据库就厉害了，利用内存的io性能可以进行极速读写和查询，虽然不能有SQL进行复杂的查询，但是mongodb能写JavaScript啊，总比那辣鸡SQL舒服多了，除了没有事务之外，其他基本就不是事了。废话不说，下面讲安装。 安装mongodb OS: MacOS 安装homebrew&emsp;&emsp;MacOS包管理工具，可以使用brew命令安装工具，和Ubuntu下的apt-get命令十分类似，不过MacOS中并没有自带homebrew，需要自己进行下载。 /usr/bin/ruby -e “$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 很简单，直接输入这一条指令就行了，不过必须要有Xcode才能运行成功，下载时如果发现没有Xcode会提示安装，期间需要输入密码。 使用homebrew安装mongodb&emsp;&emsp;其实还有其他的方法可以安装mongodb，比如直接从官网下载，不过需要自己配置环境变量和写配置文件，然而我比较懒，使用homebrew安装的mongodb是自动配置好环境变量的，所以就使用这种方法了。 brew install mongodb 简单粗暴，一个命令就装完了，不过需要点配置，先在根目录(就是跟主机名一样的那个目录)下，创建/data/db文件夹，现在直接输入一个mongod指令是可以直接打开数据库的，不过会报Warning，因为mongodb是可以不需要用户就可以进入的，但是会对你进行警告，所以现在要添加一个账户。先进入数据库。输入指令,出现>就代表进入了数据库指令界面。 >use admin 切换到admin。 >db.createUser( { user: “admin”, //用户名 pwd: “passwd”, //密码 roles: [ { role: “userAdminAnyDatabase”, db: “admin” } ] //设置权限 }) 添加用户，权限为userAdminAnyDatabase，可以管理所有用户。然后可以执行命令 mongod –auth –port 27017 –dbpath ~/data/db --auth表示需要用户验证，--port表示端口号，默认就是27017，--dbpath表示数据库存储位置。 再开启一个命令行界面，输入指令mongo，在之前的命令行界面可以看到。 2019-02-05T22:32:28.130+0800 I NETWORK [listener] connection accepted from 127.0.0.1:49902 #1 (1 connection now open) 说明接入了一个服务。接着输入指令。 > use adminswitched to db admin> db.auth(‘root’,’root’);1 切换到admin之后用db.auth(“用户名”,”密码”);就可以进入用户了，1表示成功，主命令行会出现如下内容，表示认证成功。 2019-02-05T22:35:38.116+0800 I ACCESS [conn1] Successfully authenticated as principal admin on admin 这就算打开了，不过还要知道这个数据库怎么关，根据网上的资料来说，不能直接强制关闭，需要在界面中执行db.shutdownServer();命令，于是我愉快的执行了这个指令，结果…… assert failed : unexpected error: Error: shutdownServer failed: not authorized on admin to execute command { shutdown: 1.0 }Error: assert failed : unexpected error: Error: shutdownServer failed: not authorized on admin to execute command { shutdown: 1.0 } at Error () at doassert (src/mongo/shell/assert.js:11:14) at assert (src/mongo/shell/assert.js:20:5) at DB.shutdownServer (src/mongo/shell/db.js:212:9) at (shell):1:4 emmmm……他给我抛了个异常，费了劲跑到了官网查看一下官方文档，发现网上那些教程净瞎写，一篇破教程被十几个人转发还没人发现不对，也是服气。原来在mongodb并不像mysql一样有一个可以拥有一切权限的admin用户，而且可以看一下mongodb也根本没有一个admin库，所谓userAdminAnyDatabase权限也就是可以管理所有用户，并没有权限关闭数据库，所以我们要给这个用户添加可以shutdown角色hostManger。 > db.grantRolesToUser( “admin” , [ { role: “hostManager”, db: “admin” } ]) 现在进入admin登录用户后运行db.shutdownServer(); server should be down…2019-02-05T22:50:38.485+0800 I NETWORK [js] trying reconnect to 127.0.0.1:27017 failed2019-02-05T22:50:38.487+0800 I NETWORK [js] reconnect 127.0.0.1:27017 failed failed 这就已经关闭了，同时也可以看见运行mongodb的那个命令行进程也关闭了。 &emsp;&emsp;具体怎么用再说吧，等后面学习总结。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>nosql</tag>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本数据结构]]></title>
    <url>%2F2019%2F02%2F02%2F%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[基本数据结构&emsp;&emsp;虽然以前都学过也都用过，但是并没有具体总结过，这里权当是复习了，使用C++的面对对象方法重新实现一下这几个数据结构。 1. 栈&emsp;&emsp;一种动态集合，增加和删除操作元素的位置都是预定好的，在栈中，最先被删除的元素就是最后被放入的元素，实行的是后进先出，我们把数据放入栈称作压入，把数据拿出栈叫做弹出，一般把栈比做把网球放进球筒中，拿出来的时候肯定先拿出最后放进去那个，打个不恰当的比方就是一个人吃了再吐,先上代码。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;iostream&gt;using namespace std;template&lt;class T&gt;class node&#123; public: T value; //储存的值 node&lt;T&gt;* next; node() :next(nullptr)&#123;&#125; //构造函数 node(T t) :value(t), next(nullptr)&#123;&#125;&#125;;template&lt;class T&gt;class myStack&#123; int cnts; //入栈数量 node&lt;T&gt; *head; //栈的头部public: myStack()&#123; cnts = 0; head = new node&lt;T&gt;; &#125; void stackPush(T arg); //入栈 T stackPop(); //出栈 T stackTop(); //获取栈顶元素 void printStack(); //打印栈 int counts(); //获取栈内元素个数 bool isEmpty(); //判断空&#125;;template&lt;class T&gt;void myStack&lt;T&gt;::stackPush(T arg)&#123; node&lt;T&gt; *pnode = new node&lt;T&gt;(arg); //申请入栈元素的空间 pnode-&gt;next = head-&gt;next; head-&gt;next = pnode; cnts++;&#125;template&lt;class T&gt;T myStack&lt;T&gt;::stackPop()&#123; if (head-&gt;next!=nullptr) &#123; node&lt;T&gt;* temp = head-&gt;next; head-&gt;next = head-&gt;next-&gt;next; T popVal = temp-&gt;value; delete temp; return popVal; &#125;&#125;template&lt;class T&gt;T myStack&lt;T&gt;::stackTop()&#123; if (head-&gt;next!=nullptr) &#123; return head-&gt;next-&gt;value; &#125;&#125;template&lt;class T&gt;void myStack&lt;T&gt;::printStack()&#123; if (head-&gt;next != nullptr) &#123; node&lt;T&gt;* temp = head; while (temp-&gt;next != nullptr) &#123; temp = temp-&gt;next; cout &lt;&lt; temp-&gt;value &lt;&lt; endl; &#125; &#125;&#125;template&lt;class T&gt;int myStack&lt;T&gt;::counts()&#123; return cnts;&#125;template&lt;class T&gt;bool myStack&lt;T&gt;::isEmpty()&#123; if (cnts) return false; else return true;&#125; &emsp;&emsp;这回就直接写一个C++的模版类stack.hpp，扔到头文件里是为了更好的调用。我觉得一个类能更好的描述一个操作集合，里面的数据用了链表结构储存，关于链表下面再说。&emsp;&emsp;当这个对象被实例化的时候，这个栈是空的，此时cnts=0，如果对一个空栈进行弹出操作，那么通常会抛出一个异常，这叫做栈下溢，如果添加数据超过存储上限，称为栈上溢，不过书上这么说是因为书上是用数组实现的，而链表长度不定，最大长度理论上和内存条大小有关，所以不考虑栈上溢，而且链表增加与删除只需要修改节点就行了，非常容易实现，栈的插入、删除、判空的操作时间均为O(1)。 2. 队列&emsp;&emsp;队列的插入操作叫做入队，删除操作叫做出队，队列与栈的操作相反，是先进先出，队列有队头与队尾，与我们排队一样，先到的人先办事，废话不说，上代码。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;iostream&gt;using namespace std;template&lt;class T&gt;class node&#123; public: T value; //储存的值 node&lt;T&gt;* next; node() :next(nullptr)&#123;&#125; //构造函数 node(T t) :value(t), next(nullptr)&#123;&#125;&#125;;template&lt;class T&gt;class myQueue&#123; public: int cnts; //入队数量 node&lt;T&gt; *tail; //队的尾部 node&lt;T&gt; *head; //队的头部 myQueue()&#123; cnts = 0; tail = new node&lt;T&gt;; head = new node&lt;T&gt;; head-&gt;next=tail; &#125; void enqueue(T arg); //入队 T dequeue(); //出队 void printQueue(); //打印队列 int counts(); //获取队列内元素个数 bool isEmpty(); //判断空&#125;;template&lt;class T&gt;void myQueue&lt;T&gt;::enqueue(T arg)&#123; node&lt;T&gt; *pnode = new node&lt;T&gt;(arg); //申请入队元素的空间 if(cnts==0)&#123; head-&gt;next=pnode; tail-&gt;next=pnode; &#125;else&#123; head-&gt;next-&gt;next=pnode; head-&gt;next=pnode; &#125; cnts++;&#125;template&lt;class T&gt;T myQueue&lt;T&gt;::dequeue()&#123; if(cnts!=0)&#123; node&lt;T&gt;* temp = tail-&gt;next; tail-&gt;next = tail-&gt;next-&gt;next; T popVal = temp-&gt;value; delete temp; cnts--; return popVal; &#125; &#125;template&lt;class T&gt;void myQueue&lt;T&gt;::printQueue()&#123; if (tail-&gt;next != nullptr) &#123; node&lt;T&gt;* temp = tail; while (temp-&gt;next != nullptr) &#123; temp = temp-&gt;next; cout &lt;&lt; temp-&gt;value &lt;&lt; endl; &#125; &#125;&#125;template&lt;class T&gt;int myQueue&lt;T&gt;::counts()&#123; return cnts;&#125;template&lt;class T&gt;bool myQueue&lt;T&gt;::isEmpty()&#123; if (cnts) return false; else return true;&#125; &emsp;&emsp;同样的，队列队删除、插入、判空操作需要的时间也都是O(1)。 3. 链表&emsp;&emsp;链表中的各个对象按线性顺序排列，与数组不同，链表的存储并不是一整块内存区域，也就是说他顺序并不是由下标来决定的，而是由每一个元素中的指针来决定的，在内存中的表现就是他存储的数据是离散的，而且长度可以不确定，大小随着长度增长而增长，其长度理论上可以占满整个内存，在实现队列和栈时并没有对容量上限作出检查的原因就是如此。&emsp;&emsp;链表中的每一个节点就是一个对象，每一个对象都有一个key和一个指针，有时还会包含一些卫星数据，如果x为链表中的一个元素，那么x的指针x.next则指向他的下一个后继元素，一般链表都会有一个头节点，称为头，这个节点相当于一个“柄”，他的后面连接着整条链表，我们通常通过这个“柄“对这个链表操作，最后一个节点被称为尾，头节点的指针为空，说明该链表为空。&emsp;&emsp;链表不止一种形式，上面说的是单链表，还有一种双向链表，在单链表的基础上，每一个节点增加了一个前驱指针，可以从链表的头和尾同时进行访问，也就是能够进行顺序和逆序操作。此外还有循环链表，这种链表的尾指针指向头指针，直观看来他的结构是闭合的，是一个各个元素组成的圆环，下面讨论的都是乱序的双向链表,而且有头节点。&emsp;&emsp;先看一下关于链表的实现。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;iostream&gt;using namespace std;template&lt;class T&gt;class node&#123; public: T value; //储存的值 node&lt;T&gt;* next;//后继指针 node&lt;T&gt;* pre;//前驱指针 node() :next(nullptr)&#123;&#125; //构造函数 node(T t) :value(t), next(nullptr)&#123;&#125;&#125;;template&lt;class T&gt;class Link&#123; private: int count; node&lt;T&gt; *head;//头节点 public: Link()&#123; count=0; head = new node&lt;T&gt;; &#125; void addnode(T t);//增加节点 void deletenode(T t);//删除节点 node&lt;T&gt;* searchnode(T t);//查找节点 void printlink();//打印链表&#125;;template&lt;class T&gt;void Link&lt;T&gt;::addnode(T t)&#123; node&lt;T&gt; *p=new node&lt;T&gt;(t); if(count!=0)&#123; p-&gt;next=head-&gt;next; head-&gt;next-&gt;pre=p; head-&gt;next=p; p-&gt;pre=head; &#125;else&#123; p-&gt;next=head-&gt;next; head-&gt;next=p; p-&gt;pre=head; &#125; count++;&#125;template&lt;class T&gt;node&lt;T&gt;* Link&lt;T&gt;::searchnode(T t)&#123; if(head-&gt;next!=nullptr)&#123; node&lt;T&gt; *temp; temp=head; while(temp-&gt;next!=nullptr)&#123; temp = temp-&gt;next; if (temp-&gt;value==t) &#123; return temp; &#125; &#125; cout&lt;&lt;"未找到该元素"&lt;&lt;t&lt;&lt;"！"&lt;&lt;endl; return nullptr; &#125; return nullptr;&#125;template&lt;class T&gt;void Link&lt;T&gt;::deletenode(T t)&#123; node&lt;T&gt; *temp; temp=searchnode(t); if (temp!=nullptr) &#123; if(temp-&gt;pre!=nullptr)&#123; temp-&gt;pre-&gt;next=temp-&gt;next; &#125; if(temp-&gt;next!=nullptr)&#123; temp-&gt;next-&gt;pre=temp-&gt;pre; &#125; &#125; count--;&#125;template&lt;class T&gt;void Link&lt;T&gt;::printlink()&#123; if (head-&gt;next != nullptr)&#123; node&lt;T&gt;* temp = head; while (temp-&gt;next != nullptr)&#123; temp = temp-&gt;next; cout &lt;&lt; temp-&gt;value &lt;&lt; " "; &#125; cout&lt;&lt;endl; &#125;&#125; &emsp;&emsp;searchnode使用简单的线性方法去遍历链表并返回元素指针，如果不存在key值为t的对象，则返回nullptr，在搜索有n个对象的链表nullptr的最坏运行时间为$\Theta$(n)，也就是遍历整条链表。&emsp;&emsp;addnode可以像链表中插入关键字为t的元素，将其链接在链表的前端，其运行时间为O(1)。&emsp;&emsp;deletenode将一个元素x从链表中移除，需要先通过searchnode找到该对象的指针，通过修改其前一个元素和后一个元素的前驱指针与后继指针即可将其移出链表，操作时间为O(1)，但是删除操作首先调用了searchnode方法，所以又耗费了$\Theta$(n)时间，所以其最坏情况为$\Theta$(n)。&emsp;&emsp;printlink使用线性方法遍历整个链表，并逐一打印其元素的值，由于其必定遍历整条链表，所以对于n个对象的链表来说，他的运行时间为$\Theta$(n)。&emsp;&emsp;《算法导论》中还介绍了一种叫做哨兵的哑对象，代表NIL，属性与其他对象相同，它可以将常规的双向链表转化为有哨兵的双向循环链表，它位于表头与表尾之间，next指向表头，pre指向表尾，类似的，表尾的next和表头的pre都指向哨兵，哨兵的next指向表头，我们可以去掉head，把他的引用代替为对哨兵.next的引用，空链表只有一个哨兵，他的next和pre都指向他自己。哨兵并不能降低该数据结构操作的时间渐进界，但是可以降低一个常数因子，可以做到代码简洁，但是并不能提高速度，如果有多条短链表的话，就不建议使用哨兵，因为会加大内存开销。 4. 有根树&emsp;&emsp;链表可以推广到任意的同构数据结构，比如对栈和队列，我就是使用链表对书上用数组描述的伪代码进行重构。树与链表很类似，都是使用节点进行数据存储，但是链表是一条长链，而树是分叉的，指向其他节点的指针并非一个，会随树的种类而变化。 4.1 二叉树&emsp;&emsp;顾名思义，这个树有两个叉，二叉树的每一个节点存在着一个属性和三个节点：p、left、right，分别代表父节点、左子节点和右子节点，如果p节点为空，则说明该节点为根节点，如果p根节点为空，则说明该二叉树为空，如果二叉树为近似完全二叉树(若设二叉树的深度为k，除第k层外，其他各层（1～（k-1）层）的节点数都达到最大值，且第k层所有的节点都连续集中在最左边)，可以将其称之为堆(不是Java的垃圾堆)，后面讲到堆排序的会具体说明。二叉树的代码等到对二叉搜索树进行总结时再贴出。 4.2 分支无限制有根树&emsp;&emsp;这个货就厉害了，他的分叉没有限制，但是麻烦的是因为他们没有限制，所以不知道他下面到底连了几个节点，而且如果设置一个很大的常数k作为子节点数量，但是只有几个子节点有数据，那么内存空间就大大的被浪费了。&emsp;&emsp;不过还是有方法解决这个问题，而且对于任意n个子节点的有根树来说，只需要O(n)的储存空间。这种方法叫做左孩子右兄弟表示法，与二叉树类似，有一个指向父节点的p指针，但是指向子节点的指针并不是n个，而是只有两个指针left-child和right-sibling。&emsp;&emsp;left-child指向该节点众多子节点中最左侧的那一个节点，right-sibling指向与自己同级的右侧相邻的兄弟节点。left-child为空表示其没有子节点，right-sibling为空表示其为同级中最右侧节点。&emsp;&emsp;树还有很多表示方法，等到后面学其他数据结构的时候再进行总结。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归分治]]></title>
    <url>%2F2019%2F02%2F01%2F%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[递归分治&emsp;&emsp;在之前的归并排序中，使用了递归分治的方法，整个算法经历了三个过程。&emsp;&emsp;分解：将原问题划分为一个个子问题，子问题与原问题形式一样，只是规模更小。&emsp;&emsp;求解：递归的求出子问题。如果子问题规模足够小，停止递归，直接求解。&emsp;&emsp;合并：将子问题的解组合成原问题的解。&emsp;&emsp;当问题足够大时，需要递归求解，这就叫做递归情况，当问题已经分解到足够小时并且不用再递归时，递归已经“触底”，进入基本情况。 1.递归式&emsp;&emsp;递归与分治紧密相关，递归式可以很清楚的刻画分治的运行时间，递归式是一个等式或者一个不等式，可以用更小输入上的一个函数值来描述一个函数。在算法分析中，我用递归式描述了归并排序最坏运行时间T(n)。 $$T(n) =\begin{cases} Θ(1)&amp;n = 1\ 2T(n/2)+ Θ(n)&amp;n &gt; 1 \end{cases}$$ 求解后得到T(n) = $\Theta$(nlgn)。&emsp;&emsp;递归并不是一定要等分，也可以将问题划分为规模不等的子问题，如2/3与1/3的划分，分解和合并都是线性的，这样的递归式就是T(n) = T(2n/3)+T(n/3)+$\Theta$(n)。&emsp;&emsp;有三种求解递归式的方法，可以得出算法为“$\Theta$”或“O”的渐进界方法。 1.1 代入法&emsp;&emsp;这个方法比较玄学，因为第一步需要猜，首先需要猜出解的形式，然后用数学归纳法求出解的常数，并证明解是正确的。当将归纳假设应用于较小值时，将猜测的函数代入，所以叫“代入法”。但是首先我们要猜对解的形式。&emsp;&emsp;由于这个方法并没有一个通用的公式，解出来基本靠经验和运气，所以不再往深处讨论。细节部分翻《算法导论》。 1.2 递归树法&emsp;&emsp;画出递归树是一个非常直观的方法，像在算法分析时为归并排序画出的递归树一样，在树中，每一个节点代表每一个子问题的代价，子问题对应某一次递归函数的调用。将树中每层的代价求和，可以得到每一层的代价，，将所有层代价求和，可以得到递归树的总代价。&emsp;&emsp;递归树可以生成猜测，然后用代入法验证猜测是否正确，如果在画递归树时代价求和十分准确，那么也可以直接用递归树证明解是否正确。 1.3 主方法&emsp;&emsp;主方法为递归式提供了一个通式 T(n) = aT(n/b)+f(n) 其中a &gt;= 1、b &gt; 1且都是常数，f(n)是渐进正函数。这个公式描述了一个算法的运行时间：他将规模为n的问题分解为a个子问题，每个子问题规模为n/b，其中a和b都是正常数。a个子问题递归的求解，每个花费时间为T(n/b)。函数f(n)包含了问题分解和子问题解合并的代价。因为n/b不一定为整数，所以一般将T(n/b)替换为T($\lfloor$n/b$\rfloor$)或者T($\lceil$n/b$\rceil$)。，并不会影响渐进式性质。 主定理：令a &gt;= 1和b &gt; 1是常数，f(n)是一个函数，T(n)是定义在非负整数上的递归式 T(n) = aT(n/b)+f(n)其中将n/b解释为$\lfloor$n/b$\rfloor$或者$\lceil$n/b$\rceil$。T(n)有如下渐进界。&emsp;&emsp;1.若某个常数$\epsilon$ &gt; 0 有f(n) = O(nlogba-$\epsilon$)，则T(n) = $\Theta$(nlogba)&emsp;&emsp;2.若f(n) = $\Theta$(nlogba)，则T(n)=$\Theta$(nlogbalgn)&emsp;&emsp;3.若对某个常数$\epsilon$ &gt; 0有f(n) = Ω(nlogba+$\epsilon$)，且对某个常数c &lt; 1和所有足够大的n有af(n/b) &lt;= cf(n)，则T(n) = $\Theta$(f(n))。 &emsp;&emsp;先来尝试理解一下主定理的含义，这三种情况都是将函数f(n)与函数nlogba比较。直觉上，两个函数的较大者决定了递归式的解。nlogba更大，就是情况1，解为T(n)=$\Theta$(nlogba)。如果f(n)更大，就是情况3，解为T(n) = $\Theta$(f(n))。若两个函数相当，就是情况2，要再乘上一个对数因子解为T(n)=$\Theta$(nlogbalgn)=$\Theta$(f(n)lgn)。&emsp;&emsp;第一种情况下并不是f(n)小于$\Theta$(nlogba)就够了，而是要多项式的意义上小于。f(n)必须渐进的小于nlogba，要相差一个因子n$\epsilon$，$\epsilon$是大于0的常数。第三种情况与第一种相似，并且要满足“正则“条件af(n/b)&lt;=cf(n)。&emsp;&emsp;这三种情况并未覆盖所有可能性，三种情况之间都有一定的缝隙，比如f(n)和nlogba并不是形式意义上的大于或小于关系，这种情况无法使用主定理。 主方法使用 &emsp;&emsp;使用主定理时只需要确定情况即可得到解。举个栗子 T(n) = 9T(n/3)+n 对于这个递归式，a = 9,b = 3,f(n) = n,所以nlogba = nlog39 = $\Theta$(n2)。f(n) = O(nlog39-$\epsilon$)，其中$\epsilon$ = 1，适用于情况1，得到解T(n) = $\Theta$(n2)。情况2和情况3的解法与此类似。证明部分见《算法导论》。 2. 最大子数组问题&emsp;&emsp;在一个数组中找出最大的非空连续子数组。 2.1 暴力破解&emsp;&emsp;尝试对每一种情况进行组合，n个数中一共有C(n,2)种组合，C(n,2) = $\Theta$(n2)，每次操作至少也是个常量，所以这种方法的运行时间为Ω(n2).很显然，暴力破解代价有点大。&emsp;&emsp;从另外一个角度来看看输入的数据。目的是找到一段数据，使其从开头到结尾的净变化值最大，所以现不看每次输入的数据，而是每次输入数据的变化值，定义第i个数的变化为第i个数与第i-1个数之差，将其看作数组A，问题就转化为数组A的和最大非空连续子数组，这样的连续子数组为最大子数组，乍一看对于一个n个数的串，我们还是需要检查C(n-1,2)=$\Theta$(n2)个子数组，重新组织计算方式，利用之前计算出的子数组和来计算当前子数组的和，使得每个子数组的和计算时间为O(1)，使暴力破解花费的时间为$\Theta$(n2)，代价还是有点大，我们需要将运行时间限制在o(n2)。 2.2 分治法&emsp;&emsp;首先说明，只有当数组中包含负数时，最大子数组大问题才有意义，否则，最大子数组直接就是数组A。&emsp;&emsp;假定我们寻找数组A的最大子数组，我们需要将数组划分为两个规模大致相同的两个子数组，也就是说找到中央位置，然后将其对半拆分，在数组A[low..high]中的任何子数组必定满足一下条件。 完全位于数组A[low..mid]中，low &lt;= i &lt;= j &lt;= mid. 完全位于数组A[mid+1..high]中，mid &lt; i &lt;= j &lt;= high 跨越中点，low &lt;= i &lt;= mid &lt;= j &lt;= high &emsp;&emsp;最大子数组也必定在这三种情况之内，我们可以递归求解A[low..mid]和A[mid+1..high]的最大子数组，这两个子问题与原问题一样，只是规模更小。剩下的工作就是寻找跨越中点的最大子数组，然后在三者之间挑选值最大者。此时问题加入了限制，子数组必须跨越中点，任何跨越中点的子数组都由A[i..mid]和A[mid+1..j]组成，只要找出形如A[i..mid]和A[mid+1..j]的最大子数组，然后合并即可，下面是该操作的C++实现。1234567891011121314151617181920212223242526272829303132333435int verylow=numeric_limits&lt;int&gt;::lowest();;class node&#123; public: int left; int right; int sum;&#125;;node find_max_crossing_subarray(int *A,int low,int mid,int high)&#123; int left_sum=verylow; int max_left,right_sum,max_right; int sum=0; for(int i = mid; i &gt;= low; i--)//求出左半侧最大子数组 &#123; sum=sum+A[i];//累计求和 if(sum&gt;left_sum)&#123;//逐个相加筛选最大和 left_sum=sum; max_left=i;//记录下标 &#125; &#125; right_sum=verylow; sum=0; for(int j = mid+1; j &lt;= high; j++)//求右侧最大子数组，与上同 &#123; sum=sum+A[j]; if(sum&gt;right_sum)&#123; right_sum=sum; max_right=j; &#125; &#125; node message; message.left=max_left; message.right=max_right; message.sum=left_sum+right_sum; return message;&#125; &emsp;&emsp;如果子数组包含n个元素(n=high-low+1)，调用find_max_crossing_subarray将花费$\Theta$(n)的时间，两次for循环每次花费$\Theta$(1)，第一个for循环执行了mid-low+1次迭代，第二次循环执行了high-mid次迭代，总循环迭代次数为 (mid-low+1)+(high-mid) = high-low+1 = n find_max_crossing_subarray是线性时间的，现在可以对最大子数组进行分治。1234567891011121314151617181920212223node find_maximum_subarray(int *A,int low,int high)&#123; if (high==low)&#123;//数组只有一个元素，本身就是最大和 node n; n.left=low; n.right=high; n.sum=A[low]; return n; &#125; node left_node,right_node,cross_node; int mid=(low+high)/2;//子数组划分 //递归求解左右最大子数组 left_node=find_maximum_subarray(A,low,mid);//左子数组 right_node=find_maximum_subarray(A,mid+1,high);//右子数组 cross_node=find_max_crossing_subarray(A,low,mid,high);//跨越中点的最大子数组，可以看作合并 if(left_node.sum&gt;=cross_node.sum&amp;&amp;left_node.sum&gt;=right_node.sum)&#123;//判断，返回最大子数组 return left_node;//最大子数组在左边 &#125;else if(right_node.sum&gt;=left_node.sum&amp;&amp;right_node.sum&gt;=cross_node.sum) &#123; return right_node;//最大子数组在右边 &#125;else&#123; return cross_node;//最大子数组跨越中点 &#125;&#125; 2.3 分治算法分析&emsp;&emsp;在find_maximum_subarray中，首先现花费常量的时间对n = 1做时间分析，直接得出T(1) = $\Theta$(1)。&emsp;&emsp;当n &gt; 1时开始递归。12行和13行求解的问题均为n/2个元素的子数组，所以每个子数组求解的时间为T(n/2),因为需要求左子数组和右子数组两个问题，所以运行总时间为2T(n/2)，14行调用find_max_crossing_subarray花费了$\Theta$(n)，后面的判断仅仅花费了$\Theta$(1)。因此可以列出等式； T(n) = $\Theta$(1)+2T(n/2)+$\Theta$(n)+$\Theta$(1) = 2T(n/2)+$\Theta$(n) 与上面的等式进行组合，可以得到： $$T(n) =\begin{cases} Θ(1)&amp;n=1\ 2T(n/2)+ Θ(n)&amp;n&gt;1 \end{cases}$$ 和归并排序的递归式一样。&emsp;&emsp;接下来用主方法来求解这个递归式。对于递归式： T(n) = 2T(n/2)+$\Theta$(n) a = 2，b = 2，f(n) = $\Theta$(n)，因此nlogba = nlog22 = n。因为f(n) = $\Theta$(n)，对应情况2，于是得到解T(n) = $\Theta$(nlgn)。我们得到了一个复杂度优于暴力破解的算法，递归分治可以给出一个渐进最快的算法，但是有时候还会有更快的算法，比如最大子数组问题还存在着一个速度更快的线性算法，等到学习总结到了动态规划再对该方法讨论。 &emsp;&emsp;《算法导论》中还有一个矩阵乘法的Strasson算法，虽然知道怎么写，也明白那样做可以减少一次矩阵运算，但是想不出来为什么把矩阵这么拆分组合，等我想通了再更新一下。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渐进记号]]></title>
    <url>%2F2019%2F01%2F31%2F%E6%B8%90%E8%BF%9B%E8%AE%B0%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[渐进记号&emsp;&emsp;在算法分析里面对算法运行时间以及效率问题分析时，当n的规模变得足够大时，我们引入了渐进分析记号$\Theta$来描述当输入规模无限大时，算法运行时间如何随输入规模变大而变大，现在来记录一下另外几种渐进记号约定，用来刻画算法某个其他其他方面的函数(空间与时间)。 &emsp;&emsp;在了解算法运行时间时，我们有时也要在意到底需要哪个运行时间，不是所有时候都需要最坏运行时间，我们希望有一个综合性的来刻画任何输入的运行时间，所以我们需要更多的渐进记号。 1. $\Theta$记号&emsp;&emsp;在分析插入排序与归并排序的运行时间时引入了这个记号插入排序的最坏运行时间为T(n)=$\Theta$(n2)，而归并排序只有T(n)=$\Theta$(nlgn)。&emsp;&emsp;来重新定义一下这个记号，对于一个给定的g(n)，用$\Theta$(n)表示一个函数集合： $\Theta$(g(n)) = {f(n):存在正常量c1、c2和n0，使得所有n &gt;= n0,有0 &lt;= c1g(n) &lt;= f(n) &lt;= c2g(n)} &emsp;&emsp;若存在正常量c1、c2能够在n足够大时，让函数夹在c1g(n)与c2g(n)之间，则f(n)就属于$\Theta$(g(n)),这里的$\Theta$(g(n))是一个函数集合，而非一个函数，所以我在算法分析里简单的把$\Theta$记为了去掉低阶项，忽略系数，这是一个非形式化的概念。在下面的图像中可以看出f(n)高于c1g(n)或者低于c2g(n)，换一句话说，对于所有的n&gt;=n0,f(n)存在一个常量因子等于g(n)，我们称g(n)为f(n)的渐进紧确界。 &emsp;&emsp;$\Theta$(g(n))要求其内的每一个成员f(n)都渐进非负，即n足够大时，f(n)非负(g(n)本身也必须非负，否则集合$\Theta$(g(n))为0)，这个要求对其他符号也成立。 $\Theta$符号有一个活用，当出现$\Theta$(1)时，并没有什么变量趋于无穷，所以$\Theta$(1)用来指任意一个常量或者某个关于变量的常量函数，其他符号也一样。 2. O记号&emsp;&emsp;当我们只需要一个函数的渐进上界的时候，我们采用O记号来表示。对于给定的函数g(n)，用O(g(n))来表示一下函数集合： O(g(n)) = {f(n)：存在正常量c和n0，使得对所有n &gt;= n0，有0 &lt;= f(n) &lt;= cg(n)}。 &emsp;&emsp;用O给出了一个函数在常量因子中的一个上界，从图中可以看出，在n0及其有边的所有n值中，f(n)总是小于或者等于cg(n)。 &emsp;&emsp;f(n)=$\Theta$(g(n))是一个比f(n)=O(g(n))更强的概念，f(n)=$\Theta$(g(n))包含f(n)=O(g(n))，按照集合论的方法，写作$\Theta$(g(n)) $\subseteq$ O(g(n))，所以如果证明了任意二次函数 an2+bn+c a &gt; 0 如果证明了该函数在$\Theta$(n2)中，也就证明了这个函数在O(n2)中，任意线性函数an+b a &gt; 0也在O(n2)中。&emsp;&emsp;O记号可以仅仅通过检查算法的总体结构来描述算法的运行时间，例如插入排序的双重循环结构中就会产生一个O(n2)的上界：内层循环的每一次代价至多为O(1)，下标i与j均最多为n，双重循环会产生至多n2次访问。&emsp;&emsp;O通常用来修限制算法的最坏运行时间，在每一次输入时，对于插入排序的最坏时间O(n2)适用于每一个输入。但是在插入排序最坏运行时间$\Theta$(n2)并不意味着每一次输入运行时间界都是$\Theta$(n2)，例如当输入已经被排序时，这时候运行时间界就是$\Theta$(n)。&emsp;&emsp;一般当我们说“运行时间为O(n2)”时，指存在一个O(n2)的函数f(n)，使得对任意n，不管选择什么特定规模的n输入，运行时间上界都是f(n)，这就是运行的最坏情况时间为O(n2)。 3. Ω记号&emsp;&emsp;有运行时间上界，当然对应的也有运行时间下界，称为函数的渐进下界，用符号Ω表示，对于给定的函数g(n)，用Ω(g(n))来表示一下函数集合： Ω(g(n)) = {f(n):存在正常量c&lt;和n0，使得所有n&gt;=n0,有0 &lt;= cg(n) &lt;= f(n)} 下图可以直观解释Ω记号的含义，这里不说太多。 &emsp;&emsp;根据上面三个符号的定义，很容易得出一个定理 对于任意两个函数f(n)与g(n)，有f(n)=$\Theta$(g(n))，当且仅当f(n) = O(g(n))且f(n) = Ω(g(n))。 &emsp;&emsp;当存在二次函数an2+bn+c a &gt; 0时，有an2+bn+c = $\Theta$(n)时，同时说明了an2+bn+c = O(n)、an2+bn+c = Ω(n)，通常用渐进上界与渐进下界来证明渐进紧确界，当一个算法的运行时间为Ω(g(n))时，对于每个值，不管选择什么输入，n足够大时，他的时间都是g(n)的整数倍，说插入排序的最好运行时间为Ω(n)，蕴含着插入排序的运行时间为Ω(n)。&emsp;&emsp;所以称插入排序的运行时间介于Ω(n)和O(n2)之间，落入n的线性函数与n的二次函数之间的任何地方。插入排序运行时间不是Ω(n2)因为存在输入使得其能在$\Theta$(n)时间内运行。如果说插入排序运行最坏运行时间为Ω(n2)并不错误，因为存在一个输入使得该算法运行时间为Ω(n2)。 4. 等式与不等式&emsp;&emsp;在渐进记号中的等号两端并非等价的，一般渐进记号在等式(或不等式)右端时，通常指集合的成员关系，比如n = O(n2)指n $\in$ O(n2)，我们将公式中的渐进记号解释为不带名称的匿名函数。入2n2+3n+1 = 2n2+$\Theta$(n),这里的$\Theta$(n)指在$\Theta$(n)集合之内的一个函数。&emsp;&emsp;这种方式可以帮我们消除等式中一些无关紧要的细节，如果只对某个算法的渐进行为感兴趣，就没必要说明所有的低阶项，都被理解为包含在了$\Theta$(n)表示的匿名函数中。&emsp;&emsp;某些情况下渐进记号可能出现在等式左边，如： 2n2+$\Theta$(n) = $\Theta$(n2) 无论怎样选择等号左边的匿名函数，总有一种办法来选择等号右边的匿名函数使等式成立。在2n2+$\Theta$(n) = $\Theta$(n2)中我们可以取$\Theta$(n)集合中的3n+1，使等式变为2n2+3n+1 = $\Theta$(n2)，这样2n2+$\Theta$(n)就在$\Theta$(n2)集合之内，可以说等式左边提供的细节比等式右边更粗糙。 5. o记号与ω记号&emsp;&emsp;O记号与Ω记号可能并非渐进紧却的，比如2n2 = O(n2)是渐进紧却的，而2n = O(n2)就不是渐进紧却的，我们用小写的o与ω定义集合。 o(g(n)) = {f(n):对任意正常量c&gt;0,存在常量n0&gt;0，使得所有n &gt;= n0,有0 &lt;= f(n) &lt; cg(n)},如2n = o(n2)但2n2 $\neq$ o(n2)。 ω(g(n)) = {f(n):对任意正常量c &gt; 0,存在常量n0 &gt; 0，使得所有n &gt;= n0,有0 &lt;= cg(n) &lt; f(n)}，如n2/2 = ω(n),而2n $\neq$ ω(n)。 &emsp;&emsp;这两个符号都是非渐进紧却的，与O记号和Ω记号最大的不同是，o记号与ω记号并不能等于g(n)关于c常量的函数。 f(n) $\in$ ω(g(n)),当且仅当 g(n) $\in$ o(f(n)) &emsp;&emsp;将f与g类比为实数a和b。 记号 含义 类比 $\Theta$ 渐进紧却界 a = b O 渐进上界 a &lt;= b Ω 渐进下界 a &gt;= b o 非紧却上界 a &lt; b ω 非紧却下界 a &gt; b 6. 函数比较&emsp;&emsp;实数的很多性质都适用于函数的渐进比较，设f(n)和g(n)渐进为正。 6.1 传递性 f(n) = $\Theta$(g(n)) 且 g(n) = $\Theta$(h(n)) 蕴含 f(n) = $\Theta$(h(n))f(n) = O(g(n)) 且 g(n) = O(h(n)) 蕴含 f(n) = O(h(n))f(n) = Ω(g(n)) 且 g(n) = Ω(h(n)) 蕴含 f(n) = Ω(h(n))f(n) = o(g(n)) 且 g(n) = o(h(n)) 蕴含 f(n) = o(h(n))f(n) = ω(g(n)) 且 g(n) = ω(h(n)) 蕴含 f(n) = ω(h(n)) 6.2 自反性 f(n) = $\Theta$f(n)f(n) = Of(n)f(n) =Ωf(n) 6.3 对称性 f(n) = $\Theta$(g(n)) 当且仅当 g(n) = $\Theta$(f(n)) 6.4 转置对称性 f(n) = O(g(n)) 当且仅当 g(n) = Ω(f(n))f(n) = o(g(n)) 当且仅当 g(n) = ω(f(n)) 6.5 三分性&emsp;&emsp;对于任意两个数a、b，有三种情况必须成立：a &gt; b、a &lt; b、a = b。任意两个实数可以比较，但不是任意两个渐进函数都可以比较。对于g(n)与f(n)，f(n) = O(g(n))和f(n) = Ω(g(n))可能都不成立。例如n与n1+sin n，因为n1+sin n的幂值在0到2之间来回摆动。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法分析]]></title>
    <url>%2F2019%2F01%2F24%2F%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[算法分析 The analysis of algorithm is the theoretical study of computer program performance and resource usage算法分析是理论研究关于计算机程序性能和资源利用的研究。 &emsp;&emsp;这一句话是MIT公开课上Charles Leiserson第一节课对于算法分析的定义。学习算法是为了如何让计算机更快，也就是解决计算机的性能问题。当然，在目前软件工程领域来讲，性能已经不是第一位了，软件的可维护性、健壮性、安全性、可扩展性、模块化、用户友好性、更多的功能都非常重要。为什么很多人更加青睐于MacOS而非Windows？因为用户友好性以及安全性，在计算机发展史上，这是一个非常大的飞跃。&emsp;&emsp;但是，所有的这些事情看似都比性能重要，我们为什么要学算法？ 1.性能与用户体验是紧密联系的。 &emsp;&emsp;打开一个应用需要等半天是不会有什么用户体验的，即便界面再漂亮也没有用。所以性能达不到需求，用户体验很难保证。 2.性能直接决定了可行与不可行。 &emsp;&emsp;程序太慢或者程序占用内存太大会直接导致程序在一些机器上不可行。 3.算法是描述程序行为的一种语言。 &emsp;&emsp;这是一门被计算机学科广泛使用的语言，已经被所欧的实践者所采用的理论语言，是程序的思考方式。Charles Leiserson用一个很有趣的例子去描述了性能为什么处于最底层。他把性能比做经济中的货币，而可维护性、用户体验是食物和水，虽然食物和水对于生命来说比金钱更重要，但他们都需要货币去换取，性能是他们的保障。这就是为什么那么多人用Java去写程序而非C，尽管前者比后者多耗费了三倍的性能，因为Java的良好特性值得人们去付出这些代价，在这里，性能就被充当为了货币去获取其他的对象，这就是性能处于底层的原因。 4.很有趣。 现在就从一个非常简单的排序问题引入算法分析。 排序问题&emsp;&emsp;这是一个很古老的问题，输入一组序列a1，a2……an。按需求后输出a1‘&lt;=a2‘&lt;=……&lt;=an‘。使得他们单调递增。 插入排序&emsp;&emsp;首先引入插入排序，插入排序的算法思想，数组从左到右将其中每一个元素依次设为key，key的左半部分是已经排序过的数组，每一次遍历就会将已排序部分增长一，而每一次循环将会把已排序数组的值一个一个向右移动，知道出现合适位置，并将key插入其中，所以这个排序称之为插入排序。下面是对《算法导论》中插入排序伪代码的C++实现。123456789101112void insertSort(int *a,int length)&#123; int key,i; for(int j=1;j&lt;length;j++)&#123;//从第二个开始遍历，直到最后一个 key=a[j];//标记当前需要插入的数 i=j-1;//i作为指针，遍历j之前的数 while(i&gt;=0&amp;&amp;a[i]&gt;key)&#123; //开始遍历，如果遍历到的数比key大，就把这个数向后移一位，知道循环完毕或者碰到比key小的数 a[i+1]=a[i]; i=i-1; &#125; a[i+1]=key;//将key插入 &#125; 这就是插入排序，现在我们对这个排序进行一个分析，首先关注运算时间问题。 1.输入本身 如果输入的数组本身有序，那么我们做的事将会很少，但是最坏情况下，也就是逆序情况下，我们将会得到最坏对运行时间。 2.输入规模 我们在输入几个元素的情况下，这个算法很快，但是如果输入几十亿个元素对话，就需要很长时间，所以输入规模越大，运行时间越长。 3.运行时间上界 这代表对用户的承诺，就是是说保证这个程序运行不会超过某个时间，相反的，要说说这个程序运行至少多长时间，这种信息就不能被当作承诺。 算法分析平均情况分析&emsp;&emsp;有些情况下会这么做，在这里T(n)就是输入规模为n下所有可能输入的期望时间，也就是概率论中所说的E(x)，但是我们需要一个输入统计的分布假设，否则期望就无从谈起，最常见的是均匀分布。 最好情况分析&emsp;&emsp;一般被称为假象，因为最好情况基本很少出现，即使出现也是仅仅针对于少量情况适用，比如对一个已排好序的数组排序，但是不包含大量其他情况。 最坏情况分析&emsp;&emsp;这是我们通常最关注的问题，我们首先设T(n)为输入规模为n时的最长运行时间，只有做最坏的打算，我们才能对我们的程序进行承诺。&emsp;&emsp;先看一下插入排序的最坏时间。 首先取决于运行他的计算机。 一般比较算法比较的是他的相对运算速度也就是同一台机子上的运行速度，所以这个一般不考虑。我们需要计算机的大局观，一种观点，就是渐进分析。 渐进分析&emsp;&emsp;渐进分析的思路是忽略掉那些依赖于机器的常量，以及不是去检查实际的运行时间，而是关注运行时间增长。&emsp;&emsp;首先采用渐进符号$\Theta$。 弃去公式的低阶项，并忽略前面的常数因子，如果公式是3n3+90n2-5n+6046,那么这个公式可以说是$\Theta$(n3)。 当n趋近于无穷大时，$\Theta$(n2)肯定比$\Theta$(n3)快，无论其他项是什么也动摇不了这个结果，即使在一台慢速计算机运行$\Theta$(n2)，在一台高速计算机运行$\Theta$(n3)。但是这两个函数相交于一个n0点，如果这个n0过大，计算机就无法计算，所以某些时候会青睐一些低速算法，尽管从渐进角度看，他们会比较慢，但在合理输入情况下他们可能会更快。&emsp;&emsp;继续分析插入排序，在逆向排序好的情况下，插入排序需要将所有项全部翻一遍，假设每一个操作耗费一个原子时间，循环中所有的操作都是原子时间，所以在上面的算法中，j从1循环到length，我们可以写成数学中的求和符号，从1到length,设length为n,对于一个给定的j值，循环将会进行$\Theta$(j)次操作，因为内层循环里的i以j-1为初值，在i每次取新值时进行固定数量的操作，i从j-1降到0。 T(n)=$\sum_{j=1}^n$$\Theta$(j)=$\Theta$(n2)连续整数求和，算术级数 对于很小的n，插入排序很快，但对于巨大的n，就不行了，我们需要一个更快的算法————归并排序。 归并排序&emsp;&emsp;首先对于数组A[1……n] 1.如果n为1，那么数组就是排好序的。2.递归递归的对A[1到n/2向上取整]的这一部分，以及A[n/2+1向上取整到n]这部分排序3.把排好序的两个表归并 归并过程如图所示实质上就是将两个已排序好对的数组，也就是A[1..N/2]和A[N/2+1..n]，进行归并，得到一个排序好的数组，每一步都是固定的操作与数组长度无关，所以对于总数为n的输入，时间是$\Theta$(n)的。&emsp;&emsp;对于这个递归，我们可以写出一个递推式。 $$T(n) =\begin{cases} Θ(1)&amp;n=1\ 2T(n/2)+ Θ(n)&amp;n&gt;1 \end{cases}$$ &emsp;&emsp;这是一个树状结构，树的末端时间只有$\Theta$(1)，而树的高度是lgn，叶的节点总数为n，完全扩展的递归树有lgn+1层，每层贡献总代价$\Theta$(n)，如果计算总数就是$\Theta$(n)lgn+$\Theta$(n)，根据渐进的思想，最后结果就是$\Theta$(nlgn)，考虑渐进，他比$\Theta$(n2)快,在数据足够大的情况下，归并排序将优于插入排序，差不多n大于30归并就更快了。下面是对《算法导论》中归并排序的C++实现。1234567891011121314151617181920212223242526272829303132333435const int N=204800;void Merge(int *arr,int p,int q,int r)&#123; int n1=q-p+1;//左数组长度 int n2=r-q;//右数组长度 int left[n1+1],right[n2+1];//开辟新的左右数组 for(int i = 0; i !=n1; ++i)&#123; left[i]=arr[p+i];//为左数组赋值 &#125; left[n1]=N;//左数组“哨兵” for(int j = 0; j!= n2; ++j) &#123; right[j]=arr[q+j+1];//为右数组赋值 &#125; right[n2]=N;//右数组“哨兵” int i=0,j=0; for(int k = p; k !=r+1; ++k)//将左右数组归并至原数组 &#123; if(left[i]&gt;right[j])&#123; arr[k]=right[j]; ++j; &#125;else&#123; arr[k]=left[i]; ++i; &#125; &#125;&#125;void MergeSort(int *arr,int p,int r)&#123; //分治法，将数组分割，将复杂问题化简为数个简单问题 if(p&lt;r)&#123; int q=(p+r)/2;//数组分割标记，中间下标 MergeSort(arr,p,q);//分割左边数组 MergeSort(arr,q+1,r);//分割右边数组 Merge(arr,p,q,r);//进行归并排序 &#125;&#125; 这就是算法分析的一部分，后面还有更多的分析方法，如果想知道更多的证明细节，详见《算法导论》。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot-使用QueryDSL查询框架]]></title>
    <url>%2F2019%2F01%2F22%2FSpringBoot-%E4%BD%BF%E7%94%A8QueryDSL%E6%9F%A5%E8%AF%A2%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[SpringBoot-使用QueryDSL查询框架(基础) QueryDSL是一个通用的查询框架，框架的核心原则是创建安全类型的查询，开始QueryDSL仅支持Hibernate（HQL），在不断开源人士加入QueryDSL团队后，陆续发布了针对JPA，JDO，JDBC，Lucene，Hibernate Search，MangoDB，Collections 和RDF(Relational Data Format) Bean等。 简述&emsp;&emsp;在使用SpringDataJPA的时候，内置的QueryByExampleExecutor对复杂查询来说显然不怎么好用，于是在这里引入一个便于我们进行复杂查询的框架————QueryDSL。这个框架可以完美的和SpringDataJPA进行融合，接下来主要说怎么用。 项目构建&emsp;&emsp;怎么搭建SpringBoot、数据源、数据库连接、配置SpringDataJPA就不说了，在原先的基础上添加项目依赖。12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;com.querydsl&lt;/groupId&gt; &lt;artifactId&gt;querydsl-jpa&lt;/artifactId&gt; &lt;version&gt;4.0.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.querydsl&lt;/groupId&gt; &lt;artifactId&gt;querydsl-apt&lt;/artifactId&gt; &lt;version&gt;4.2.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.inject&lt;/groupId&gt; &lt;artifactId&gt;javax.inject&lt;/artifactId&gt; &lt;version&gt;1&lt;/version&gt;&lt;/dependency&gt; 仅仅添加依赖还不够，我们需要在下面的&lt;plugins&gt;标签中添加插件 1234567891011121314151617&lt;!--该插件生成查询对象--&gt; &lt;plugin&gt; &lt;groupId&gt;com.mysema.maven&lt;/groupId&gt; &lt;artifactId&gt;apt-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.1.3&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;process&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;outputDirectory&gt;target/generated-sources/java&lt;/outputDirectory&gt; &lt;processor&gt;com.querydsl.apt.jpa.JPAAnnotationProcessor&lt;/processor&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; 然后在idea界面右上角打开Edit Configurations,新建一个maven，填入如图所示信息。在右上角启动这个插件。该插件会自动扫描项目内配置了@Entity的实体类，并根据实体的内定义的字段以及关联类通过JPAAnnotationProcessor自动创建Q[实体类名称]的查询实体，创建完成后会将实体存放到我们配置outputDirectory属性目录下。如图所示。 准备准备数据库信息&emsp;&emsp;先构建一个普通的User实体类,项目启动时会自动根据这个实体类建表，建表后向里面扔几条测试数据。123456789101112131415161718192021/** * @Author: cp * @Date: 2019/1/21 下午11:13 * @Version 1.0 */@Entity@Table(name = "user")public class User implements Serializable &#123; @Id @Column(name = "id") @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; @Column(name = "name") private String name; @Column(name = "age") private String age; @Column(name = "address") private String address; @Column(name = "pwd") private String pwd; /*setter and getter*/ 创建基类JPA&emsp;&emsp;正如上一篇所说，正常情况下一个项目肯定不可能就继承一个JpaRepository接口，再使用其他模块时还需要多个接口继承，如果每一个业务数据接口都继承几个相同的接口的话，对于系统设计和代码复用性来说不是个什么好的选择。所以我们需要一个基类JPA。12345678/** * @Author: cp * @Date: 2019/1/21 下午11:16 * @Version 1.0 */@NoRepositoryBeanpublic interface BaseJPA&lt;T&gt; extends JpaRepository&lt;T,Integer&gt;,JpaSpecificationExecutor&lt;T&gt;,QuerydslPredicateExecutor&lt;T&gt; &#123;&#125; @NoRepositoryBean是为了避免自动实例化。 创建对应模块JPA&emsp;&emsp;创建对应User模块的数据逻辑接口JPA，因为BaseJPA已经继承了我们所需要的所有接口，所以我们只需要继承BaseJPA就可以了。1234567/** * @Author: cp * @Date: 2019/1/21 下午11:18 * @Version 1.0 */public interface UserJPA extends BaseJPA&lt;User&gt; &#123;&#125; 执行插件生成Q结构查询实体&emsp;&emsp;这个不多说了，刚才生成过了。打开自动创建的实体后可以看到QueryDSL自动为我们创建的查询字段以及构造函数。 编写控制器&emsp;&emsp;为了方便我就不写Service层了，所有业务逻辑全部放在Controller层，不过正式开发时一定要写。12345678910111213141516/** * @Author: cp * @Date: 2019/1/21 下午11:20 * @Version 1.0 */@RestControllerpublic class UserController &#123; @Autowired private UserJPA userJPA; @Autowired private EntityManager entityManager; private JPAQueryFactory queryFactory; @PostConstruct public void initFactory()&#123; queryFactory=new JPAQueryFactory(entityManager); &#125; 声明EntityManager的注入以及JPAQueryFactory工厂对象的创建，通过@PostConstruct注解在类初始化的时候完成对JPAQueryFactory对象的实例化。 查询查询并排序12345678@RequestMapping(value = "/queryAll")public List&lt;User&gt; queryAll()&#123; QUser qUser=QUser.user;//创建查询对象 return queryFactory//查询并返回 .selectFrom(qUser)//源 .orderBy(qUser.id.desc())//根据id倒序 .fetch();//执行并返回结果集&#125; &emsp;&emsp;queryAll方法内首先获取了对应UserBean的查询实体QUserBean，通过QUserBean内自动生成的字段获取，我们使用JPAQueryFactory工厂对象的selectFrom方法来简化查询，该方法代替了select&amp;from两个方法，注意：也是仅限单表操作时可以使用。&emsp;&emsp;这样写起来感觉就像在写原生SQL，在一系列的条件都添加完成后，调用fetch方法执行我们的条件查询并且获取对应selectFrom查询实体的类型集合，要注意一点：这里如果selectFrom参数的实体类型不是User那fetch方法返回集合的类型也不是List&lt;User&gt;。&emsp;&emsp;启动后访问这个方法就可以在网页中见到这些数据，同时在控制台中也可以看见生成的SQL语句。1234567891011Hibernate: select user0_.id as id1_3_, user0_.address as address2_3_, user0_.age as age3_3_, user0_.name as name4_3_, user0_.pwd as pwd5_3_ from user user0_ order by user0_.id desc 根据主键查询数据&emsp;&emsp;这个方法是最常用的方法，现在我们有两种写法，一种是使用QueryDSL，另外一种是和SpringDataJPA结合。使用QueryDSL：12345678@RequestMapping(value = "/detail/&#123;id&#125;")public User detail(@PathVariable("id") Integer id)&#123; QUser qUser=QUser.user;//使用querydsl return queryFactory .selectFrom(qUser)//源 .where(qUser.id.eq(id))//条件 .fetchOne();//结果&#125; SpringDataJPA+QueryDSL:12345@RequestMapping(value = "/detail_2/&#123;id&#125;") public Optional&lt;User&gt; detail_2(@PathVariable("id") Integer id)&#123; QUser qUser=QUser.user;//使用querydsl return userJPA.findOne(qUser.id.eq(id));//查询并返回结果 &#125; 网上的一些教程关于SpringDataJPA+QueryDSL的方法返回值好多都是直接返回实体类，不过最新的方法已经修改为返回Optional类，用来解决万恶的空指针异常。&emsp;&emsp;这两种代码效果是一样的，都是根据主键返回对应信息，看起来SpringDataJPA+QueryDSL还简单一点，不过这只限于单表查询，一旦涉及各种复杂操作还是QueryDSL简单。在使用QueryDSL查询指定主键时，我们使用了where方法并且指定了id字段需要eq参数id，这个eq是QueryDSL内置的一个方法，用于查询指定值数据，当然其他字段也同样可以使用eq方法来完成条件查询，都是可以变通使用的。 模糊查询&emsp;&emsp;根据name字段模糊查询。12345678@RequestMapping(value = "like")public List&lt;User&gt; likeQueryByName(String name)&#123; QUser qUser=QUser.user;//使用querydsl return queryFactory .selectFrom(qUser)//源 .where(qUser.name.like("%"+name+"%"))//条件 .fetch();&#125; like是QueryDSL内置方法，只要存入条件，就可以完成模糊查询，可以看一下控制台输出的SQL语句。1234567891011Hibernate: select user0_.id as id1_3_, user0_.address as address2_3_, user0_.age as age3_3_, user0_.name as name4_3_, user0_.pwd as pwd5_3_ from user user0_ where user0_.name like ? escape '!' 更新使用SpringDataJPA更新实体&emsp;&emsp;与Hibernate一样，SpringDataJPA内置了一个save方法用于保存、更新实体内容，如果存在主键值则更新对应信息，反则是添加一条新信息。我们新添加一个方法。12345678910@RequestMapping(value = "/updateJPA")public String updateJPA()&#123; User user=new User(); user.setId(1); user.setName("王五"); user.setAge("13"); user.setPwd("321"); userJPA.save(user); return "success";&#125; 很简单，并没有什么难理解的地方，直接访问这个方法就可以看结果了，重点是先看控制台输出的SQL语句，首先输出了一条查询语句。12345678910select user0_.id as id1_3_0_, user0_.address as address2_3_0_, user0_.age as age3_3_0_, user0_.name as name4_3_0_, user0_.pwd as pwd5_3_0_ from user user0_ where user0_.id=? 这是因为SpringDataJPA先去查询数据库中有没有这个主键的信息，如果有，才会执行下面的更新语句。123456789update user set address=?, age=?, name=?, pwd=? where id=? 使用QueryDsl更新实体1234567891011121314151617181920@Transactional@RequestMapping(value = "updateDsl")public String updateByQueryDsl()&#123; User user=new User(); user.setPwd("090"); user.setAge("80"); user.setName("赵四"); user.setId(1); user.setAddress("北京"); QUser qUser=QUser.user; queryFactory .update(qUser) .set(qUser.name,user.getName()) .set(qUser.address,user.getAddress()) .set(qUser.age,user.getAge()) .set(qUser.pwd,user.getPwd()) .where(qUser.id.eq(user.getId())) .execute(); return "SUCCESS";&#125; &emsp;&emsp;与SpringDataJPA不同的是，使用save方法的时候，如果实体类中某一条是空的，那么数据库中对应字段也会被设为空，而使用QueryDsl时就可以随心所欲的选择只更新某几条信息。设置完成更新字段后需要设置更新的条件，不设置也是可以的，当然这里肯定跟原生SQL一样，不设置条件就更新表内全部的数据。最后使用execute()执行操作就行了。 敲黑板：在执行update/delete方法时必须添加事务，也就是@Transactional注解，否则会抛出异常。 这是控制台输出的语句。12345678910Hibernate: update user set name=?, address=?, age=?, pwd=? where id=? 删除使用SpringDataJPA删除实体信息1234567@RequestMapping(value = "/deletejpa")public String deletejpa()&#123; User user=new User(); user.setId(4); userJPA.deleteById(user.getId());//删除指定主键的值 return "success";&#125; &emsp;&emsp;简单粗暴，不用解释。 使用QueryDsl删除实体信息123456789101112@Transactional//这个必须有@RequestMapping(value = "/deletequery")public String deleteQueryDsl()&#123; User user=new User(); user.setId(4); QUser qUser=QUser.user; queryFactory .delete(qUser)//删除 .where(qUser.id.eq(user.getId()))//条件 .execute();//执行 return "sueecss";&#125; &emsp;&emsp;跟update方法差不多，就是把update改成delete，看起来好像比SpringDataJPA还麻烦了，但是我们引入这个框架是为了复杂查询，所以我们加一个限定条件，删除id大于四，且name值为王五的人。123456789101112131415@Transactional//这个必须有@RequestMapping(value = "/deletequeryid")public String deletequeryById()&#123; User user=new User(); user.setName("mvm"); QUser qUser=QUser.user; queryFactory .delete(qUser)//删除 .where( qUser.name.eq(user.getName()) .and(qUser.id.gt(4))//条件 ) .execute();//执行 return "success";&#125; SpringDataJPA想要完成这个就没那么简单了，看一下生成的SQL语句。1234567Hibernate: delete from user where name=? and id&gt;? 还是很规范的，输出的SQL完全根据我们设置的条件来自动生成，QueryDsl内的条件可以跟原生SQL完全一样，可以完全采用SQL的思想来编写条件。 最后&emsp;&emsp;以上是SpringDataJPA结合QueryDSL的基础操作，后续还会继续学习多表关联查询、自定义返回对象、聚合查询、子查询等复杂操作。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>SpringDataJPA</tag>
        <tag>QueryDSL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot-整合SpringDataJPA]]></title>
    <url>%2F2019%2F01%2F21%2FSpringBoot-%E6%95%B4%E5%90%88SpringDataJPA%2F</url>
    <content type="text"><![CDATA[SpringBoot-整合SpringDataJPA1.简述&emsp;&emsp;SpringDataJPA是Spring Data的一个子项目，默认底层是Hibernate，使用基于JPA的Repository,极大的减少对数据库访问的代码量，仅仅使用内部接口就可以完成简单的crud操作。 2.搭建项目&emsp;&emsp;还使用之前搭好的框架进行测试，由于是测试，为了方便就不搭建Service层了，所有逻辑代码都放在了Controller层，数据源使用alibaba的Druid数据源，关于Druid以后慢慢说，不放在这里讨论。 2.1导入依赖并修改配置文件&emsp;&emsp;首先在pom.xml原来的基础中添加配置。123456789&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.12&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt; 然后修改配置文件，添加关于Druid和SpringBootJPA的依赖123456789101112131415161718192021222324252627282930313233343536spring: mvc: view: prefix: /WEB-INF/views/ suffix: .jsp datasource: type: com.alibaba.druid.pool.DruidDataSource url: jdbc:mysql://127.0.0.1:3306/test3?characterEncoding=UTF-8 username: root password: 20141232 driver-class-name: com.mysql.jdbc.Driver #最大活跃数 maxaActive: 20 #初始化数量 InitialSize: 1 #最大连接等待时间 maxWait: 60000 #打开PSCache，并指定大小 poolPreparedStatements: true maxPoolPreparedStatementPerConnectionSize: 20 minIdle: 1 connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: select 1 from dual testWhileIdle: true testOnBorrow: false testOnReturn: false filters: stat, wall, log4j jpa: properties: hibernate: hbm2ddl: auto: update show_sql: true format_sql: true 之后还需要在入口文件ZzuliApplication中添加两条注解。12345678@SpringBootApplication@EnableAutoConfiguration@ComponentScan(basePackages = &#123;"cn.edu.zzuli"&#125;)public class ZzuliApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ZzuliApplication.class, args); &#125;&#125; @EnableAutoConfiguration禁止掉多数据源的自动注入，如果不这样做就会产生maven的依赖包冲突，导致重复依赖。@ComponentScan会扫描指定包，在指定包中寻找带注解的类。 2.2 使用JpaRepository&emsp;&emsp;与Hibernate一样，都需要一个实体类对数据库表结构进行映射，在启动项目时，会对实体类创建相应的表结构。所以先在domain包里创建StudentEntity类，get和set方法在此省略了。1234567891011121314151617181920212223242526272829package cn.edu.zzuli.domain;import cn.edu.zzuli.base.BaseEntity;import javax.persistence.*;import java.io.Serializable;/** * @Author: cp * @Date: 2019/1/20 下午3:56 * @Version 1.0 */@Entity@Table(name = "studentEntity")public class StudentEntity implements Serializable &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = "s_id") private Integer id; @Column(name = "s_name") private String name; @Column(name = "s_age") private Integer age; @Column(name = "s_address") private String address; /*getter and setter*/&#125; 对这几个注解做一下说明，使用@Entity会对实体类进行持久化操作，当JPA检测到实体类中有@Entity注解时，会在数据库中生成对应的表结构信息。@Table用来指定表名，@Id用来指定主键，配合@GeneratedValue(strategy = GenerationType.IDENTITY)指定主键自增策略，这里将主键自增交给数据库去做，所以使用IDENTITY，@Column用来指定对应表中的字段名。&emsp;&emsp;之后我们需要创建StudentJPA接口,先创建一个jpa包，在下面创建StudentJPA接口，继承JpaRepository，需要两个参数，一个是实体类对象，一个是主键类型。1234567/** * @Author: cp * @Date: 2019/1/20 下午4:01 * @Version 1.0 */public interface StudentJPA extends JpaRepository&lt;StudentEntity,Integer&gt; &#123;&#125; 我们查看JpaRepository就可以看到这个接口又继承了PagingAndSortingRepository和QueryByExampleExecutor接口，PagingAndSortingRepository又继承了CrudRepository接口，浓浓的Spring风格，基本上看名字就知道这个接口大概是干什么的，至于为什么这么设计，那就是架构的问题了。 2.1.1 CrudRepository&emsp;&emsp;看名字就知道，这个接口中包含了crud操作，也就是creat、select、delete、update、exist、count.1234567891011121314@NoRepositoryBeanpublic interface CrudRepository&lt;T, ID&gt; extends Repository&lt;T, ID&gt; &#123; &lt;S extends T&gt; S save(S var1); &lt;S extends T&gt; Iterable&lt;S&gt; saveAll(Iterable&lt;S&gt; var1); Optional&lt;T&gt; findById(ID var1); boolean existsById(ID var1); Iterable&lt;T&gt; findAll(); Iterable&lt;T&gt; findAllById(Iterable&lt;ID&gt; var1); long count(); void deleteById(ID var1); void delete(T var1); void deleteAll(Iterable&lt;? extends T&gt; var1); void deleteAll();&#125; 如果继承该接口就会拥有所有该接口的实现。 2.1.2 PagingAndSortingRepository&emsp;&emsp;顾名思义，分页和排序，而且继承了CrudRepository接口，拥有其所有的接口实现。12345@NoRepositoryBeanpublic interface PagingAndSortingRepository&lt;T, ID&gt; extends CrudRepository&lt;T, ID&gt; &#123; Iterable&lt;T&gt; findAll(Sort var1); Page&lt;T&gt; findAll(Pageable var1);&#125; 2.1.3 QueryByExampleExecutor&emsp;&emsp;这个接口就是实现条件查询和复杂查询的，可以使用exmple的方式查询。12345678public interface QueryByExampleExecutor&lt;T&gt; &#123; &lt;S extends T&gt; Optional&lt;S&gt; findOne(Example&lt;S&gt; var1); &lt;S extends T&gt; Iterable&lt;S&gt; findAll(Example&lt;S&gt; var1); &lt;S extends T&gt; Iterable&lt;S&gt; findAll(Example&lt;S&gt; var1, Sort var2); &lt;S extends T&gt; Page&lt;S&gt; findAll(Example&lt;S&gt; var1, Pageable var2); &lt;S extends T&gt; long count(Example&lt;S&gt; var1); &lt;S extends T&gt; boolean exists(Example&lt;S&gt; var1);&#125; 但是我感觉这个东西不怎么好用，以后会有替代品。 2.1.4 JpaRepository&emsp;&emsp;我们用的就是这个接口，它拥有以上所有接口的方法实现，并添加了条件查询和保存集合数据的方法，基本上简单的数据库操作就不需要写SQL了。1234567891011121314@NoRepositoryBeanpublic interface JpaRepository&lt;T, ID&gt; extends PagingAndSortingRepository&lt;T, ID&gt;, QueryByExampleExecutor&lt;T&gt; &#123; List&lt;T&gt; findAll(); List&lt;T&gt; findAll(Sort var1); List&lt;T&gt; findAllById(Iterable&lt;ID&gt; var1); &lt;S extends T&gt; List&lt;S&gt; saveAll(Iterable&lt;S&gt; var1); void flush(); &lt;S extends T&gt; S saveAndFlush(S var1); void deleteInBatch(Iterable&lt;T&gt; var1); void deleteAllInBatch(); T getOne(ID var1); &lt;S extends T&gt; List&lt;S&gt; findAll(Example&lt;S&gt; var1); &lt;S extends T&gt; List&lt;S&gt; findAll(Example&lt;S&gt; var1, Sort var2);&#125; 3.测试3.1 创建Controller层&emsp;&emsp;在controller 包中新建JPAStudentController类，这回测试就不使用JSP了，直接带上@RestController注解，并注入StudentJPA，返回json格式验证数据。12345678910/** * @Author: cp * @Date: 2019/1/20 下午4:06 * @Version 1.0 */@RestControllerpublic class JPAStudentController &#123; @Autowired private StudentJPA studentJPA;&#125; 3.2开启测试3.1.1 查询&emsp;&emsp;在JPAStudentController中添加list方法，使用JpaRepository内部实现的findAll方法。1234@RequestMapping(value = "/stu")public List&lt;StudentEntity&gt; list() &#123; return studentJPA.findAll();&#125; 接着在浏览器访问访问localhost:8080/stu，可以看到页面返回的数据。可以看到我在数据库预先准备的数据。&emsp;&emsp;除此之外，只要继承JpaRepository接口，我们还能使用方法规则进行查询，我第一次见的时候感觉挺神奇的，举个栗子，我在StudentJPA中定义StudentEntity findByName(String name);方法，他就可以直接被解析为。1select from StudentEntity where name=? 超级方便，简单的查询直接写定义这么一个方法就好了，不过弊端就是对于复杂查询，方法名会超级长，而且很难实现。&emsp;&emsp;如果想对SQL语句进行细致优化的话，我们还可以使用@Query注解自定义SQL。打开StudentJPA，在其中添加以年龄为条件的查询。12@Query(value = "select * from student_entity where s_age&gt;=?",nativeQuery = true)public List&lt;StudentEntity&gt; SelectByAge(int age); nativeQuery这个设置为true表明使用原生SQL，否则默认启用HQL。在controller层添加代码。1234@RequestMapping(value = "/age")public List&lt;StudentEntity&gt; age()&#123; return studentJPA.SelectByAge(20);&#125; 重启项目并在浏览器中输入localhost:8080/age。 3.1.2 增加&emsp;&emsp;增加数据只需要将实体类当作参数，调用StudentJPA的save方法即可。123456789@RequestMapping(value = "/add") public String add()&#123; StudentEntity entity=new StudentEntity(); entity.setAddress("郑州轻工业大学"); entity.setAge(19); entity.setName("范秉洋"); studentJPA.save(entity); return "添加成功"; &#125; save方法不仅仅用于增加，如果实体类中传入主键，那么save方法就会变为根据主键更新数据库操作，下面就不再写更新的方法了。 3.1.3 删除&emsp;&emsp;直接使用JpaRepository提供的deleteById方法即可。12345@RequestMapping(value = "/delete")public String delete(Integer userId)&#123; studentJPA.deleteById(userId); return "删除成功";&#125; 3.1.4 自定义语句&emsp;&emsp;如同在查询中使用@Query注解一样，增删改查都可以使用原生SQL对数据库操作，不过@Query只能查询，那么就需要配合另一个注解@Modifying一起使用。创建一个根据姓名和年龄删除数据的方法。123@Modifying@Query(value = "delete from student_entity where s_name=? and s_age=?",nativeQuery = true)public void deleteQuery(String name,Integer age); 如果这么写的话，会抛出一个TranscationRequiredException异常，意思就是当前操作需要事务，所以要在这个方法前加@Transactional开启自动化管理。 3.1.5 自定义BaseRepository&emsp;&emsp;正常情况下一个项目肯定不可能就继承一个JpaRepository接口，再使用其他模块时还需要多个接口继承，如果每一个业务数据接口都继承几个相同的接口的话，不是不可以，但是对于系统设计和代码复用性来说不是个什么好的选择。&emsp;&emsp;创建一个叫base的包，在里面添加BaseRepository接口，并继承JpaRepository。12345678/** * @Author: cp * @Date: 2019/1/20 下午10:29 * @Version 1.0 */@NoRepositoryBeanpublic interface BaseRepository&lt;T,PK extends Serializable&gt; extends JpaRepository&lt;T,PK&gt; &#123;&#125; @NoRepositoryBean:这个注解如果配置在继承了JpaRepository接口以及其他SpringDataJpa内部的接口的子接口时，子接口不被作为一个Repository创建代理实现类。 以后再创建接口继承BaseRepository就行了，他有JpaRepository所有实现方法。 3.1.6 分页查询&emsp;&emsp;对于一般项目来说分页是少不了的，当然，SpringDataJPA也内置了分页方法。&emsp;&emsp;先创建一个BaseEntity，添加几个字段：当前页码、每页条数、排序列，排序方法。12345678910111213141516171819202122232425/** * @Author: cp * @Date: 2019/1/20 下午10:45 * @Version 1.0 */public class BaseEntity &#123; /** * 默认页码 */ protected int page=1; /** * 默认分页数量 */ protected int size=2; /** * 排序列名为id */ protected String sidx="id"; /** * 排序规则 * @return */ protected String sord="desc"; /*getter and setter*/&#125; 修改StudentEntity类继承BaseEntity,由于数据不多，所以设定一页就两条。在JPAStudentController中添加cut方法，并添加对应分页逻辑。注意在分页中页码是从0开始的。1234567@RequestMapping(value = "/page") public List&lt;StudentEntity&gt; Page(Integer page)&#123; StudentEntity entity=new StudentEntity(); entity.setSize(2); entity.setPage(page); return studentJPA.findAll(PageRequest.of(entity.getPage()-1,entity.getSize())).getContent(); &#125; 从网上找的分页方法是使用PageRequest对象，不过使用时发现这个方法的构造方法在最新版本中被废弃了，查看源码后得知取而代之的是静态的PageRequest.of()方法。接下来重启项目并访问该方法。 3.1.6 排序&emsp;&emsp;BaseEntity预设好了对应字段，所以重新编辑page方法，将Sort对象添加在PageRequest.of()中就可以实现排序。12345678910111213@RequestMapping(value = "/page") public List&lt;StudentEntity&gt; Page(Integer page)&#123; StudentEntity entity=new StudentEntity(); entity.setSize(2); entity.setPage(page); entity.setSord("desc"); //获取排序对象 Sort.Direction sort_Direction=Sort.Direction.ASC.toString().equalsIgnoreCase(entity.getSord())?Sort.Direction.ASC:Sort.Direction.DESC; //设置排序对象 Sort sort=new Sort(sort_Direction,entity.getSidx()); //执行分页 return studentJPA.findAll(PageRequest.of(entity.getPage()-1,entity.getSize(),sort)).getContent(); &#125; 我们现在将顺序按照id倒序排序，SpringDataJPA对排序方式添加了一个枚举类型，创建Sort对象时也需要枚举对象，因为我们BaseEntity配置的是字符串所以上面多了一步判断排序方式返回枚举对象。重启项目。 4.总结&emsp;&emsp;基本操作就这么多了，包括了：CURD、分页、排序、自定义SQL、定义BaseRepository、事务处理等。用起来还是挺方便的，但是这并不是全部，后面还会对一对多、多对多等复杂查询进行总结，今天就先到这里吧。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>SpringDataJPA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot-快速搭建]]></title>
    <url>%2F2019%2F01%2F19%2FSpringBoot-%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[SpringBoot-快速搭建1.SpringBoot简述 Spring Boot makes it easy to create stand-alone production-grade Spring based Applications that you can “just run”.We take an opinionated view of the Spring platform and third-party libraries so you can get started with minimum fuss. Most Spring Boot applications need very little Spring configuration. &emsp;&emsp;摘自官网,大致意思是创建独立的、快速的、生产级的基于Spring的应用，对Spring和第三方库进行整合，轻松上手，只需要很少的配置就可以使用。 1.1优势&emsp;&emsp;在之前使用SSH(都9102年了我估计也没多少人用Struts了吧)与SSM时，虽然相对于传统的JSP+servlet+jdbc的开发模式简化了开发流程，但是在项目初期搭建的时候相当繁琐，大致需要： 1.配置xml，加载一坨配置文件. 2.配置Spring和SpringMVC，这两个还好，可以写到一个里面，配置Struts那是相当难受. 3.配置数据源，配置日志文件. 4.配置Mybatis的Mapper文件和Hibernate的配置文件 5.各种动态扫描注解 …… &emsp;&emsp;如果是在我学Django之前,我还是可以忍受这种东西的，但是学完Django之后，这种繁琐的配置就让人觉得很难受，我一直期望着Java中有一个和Django一样一个框架就可以干完所有活而且配置还非常简单的框架。得益于我喜欢在知(bi)乎上瞎逛，我了解了SpringBoot相关的技术链，并在禹州实训期间闲的没事干的情况下蹦入了这个坑，试了之后就一个字————爽！&emsp;&emsp;基本全程就几个配置文件，而且都不是xml，所有配置都是自动配置的，而且它内置tomcat，在使用idea的情况下，idea内置的各种工具可以实现全部框架的自动生成，再这里吹一波JetBrain。 突出优势：简单、快速、方便的搭建项目主流开发框架无配置集成提高开发、部署效率 2.项目搭建2.1开发环境 os:MacOS 10.13.4 ide:IDEA 2018.1.4 jdk:10.0.1 maven:3.3.9 tomcat:9.0(框架自带) 2.2新建项目&emsp;&emsp;新建项目时，点击左侧的Spring Initializr,然后点击next。 &emsp;&emsp;下一个页面是修改项目信息，第一个参数Group的域，第二个参数Artifact一般代表公司名称，这两个参数都是提供给maven的。最后一个参数Package为项目总包名，余下几个参数，Type一般都选择maven，Languge一般选择Java，也可以使用其他虚拟机语言，比如Kotlin、Groovy。Packing是打包方式，可以选择打成jar包或者war包 钩上web模版选择位置&emsp;&emsp;因为依托与maven，第一次加载时间可能比较长，因为所有配置需要从网络上去拉取，下载完毕后文件目录如图所示。看一下目录，大致分为三块： java文件：代码源文件，逻辑代码都在这里，里面那个ZzuliApplicaion是系统入口文件。 resource文件：静态资源文件，里面放着所有的静态资源和配置文件，application.properties中可以添加其他配置。 test文件：测试模块，里面内涵一个Junit测试。 外面有一个pom.xml文件，这个是maven的配置文件。 2.3 测试运行&emsp;&emsp;在之前创建的cn.edu.zzuli文件夹下创建Controller文件夹，并创建HelloWorldController类进行测试。1234567891011121314151617package cn.edu.zzuli.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;/** * @Author: cp * @Date: 2019/1/19 下午4:38 * @Version 1.0 */@RestControllerpublic class HelloWorldController &#123; @RequestMapping("/php") public String php()&#123; return "php是世界上最好的语言"; &#125;&#125; 基本上还是和SpringMVC很像的，唯一一点不同就是@RestController注解，这个注解就是原来@Controller和@ResponseBody注解的合体版。&emsp;&emsp;直接点击右上角的箭头或者启动ZzuliApplicaion类。出现这个界面就说明SpringBoot启动成功了。接着在浏览器中直接访问http://localhost:8080/php信息已被返回。 3.分析项目3.1 pox.xml文件&emsp;&emsp;SpringBoot自动生成的pox.xml文件如下12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.2.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;cn.edu&lt;/groupId&gt; &lt;artifactId&gt;zzuli&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;zzuli&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 相较于一般的pox.xml文件，这里多了一个&lt;parent&gt;标签,这个标签是在配置SpringBoot的父级依赖,有了这个，当前的项目才是SpringBoot项目，spring-boot-starter-parent是一个特殊的starter，它用来提供相关的maven默认依赖，使用它之后，常用的包依赖就可以省去version标签。&emsp;&emsp;\repository\org\springframework\boot\spring-boot-dependencies\2.0.1.RELEASE\spring-boot-dependencies-2.0.1.RELEASE.pom里面有SpringBoot的所有依赖，想了解的去这里看看 3.2 入口类&emsp;&emsp;SpringBoot项目通常有一个名为*Application的入口类，入口类里有一个main方法，这个main方法其实就是一个标准的Java应用的入口方法。&emsp;&emsp;@SpringBootApplication是SpringBoot的核心注解，它是一个组合注解，该注解组合了：@Configuration、@EnableAutoConfiguration、@ComponentScan若不是用@SpringBootApplication注解也可以使用这三个注解代替。&emsp;&emsp;其中，EnableAutoConfiguration让SpringBoot根据类路径中的jar包依赖为当前项目进行自动配置，例如，添加了spring-boot-starter-web依赖，会自动添加Tomcat和SpringMVC的依赖，那么SpringBoot会对Tomcat和SpringMVC进行自动配置。&emsp;&emsp;SpringBoot还会自动扫描@SpringBootApplication所在类的同级包以及下级包里的Bean，所以入口类建议就配置在grounpID+arctifactID组合的包名下（这里为cn.edu.zzuli包），使用idea自动创建项目的话idea会自动在这里创建。 3.3 配置文件&emsp;&emsp;SpringBoot使用一个全局的配置文件application.properties或application.yml，放置在src/main/resources目录或者类路径的/config下。&emsp;&emsp;SpringBoot不仅支持常规的properties配置文件，还支持yaml语言的配置文件。yaml是以数据为中心的语言，在配置数据的时候具有面向对象的特征。&emsp;&emsp;SpringBoot的全局配置文件的作用是对一些默认配置的配置值进行修改。这里我将application.properties修改为application.yml。 4.使用SpringBoot&emsp;&emsp;上面只是一些简单的搭建以及运行，下面再深入了解一下SpringBoot的应用。SpringBoot的默认视图支持是 Thymeleaf 模板引擎。但是咱不会，只好还用JSP。 4.1集成JSP1.在pom.xml文件中集成JSP，向pom.xml中添加1234567891011121314&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 2.在application.yml文件配置视图解析器，将我们的 JSP 文件重定向到 /WEB-INF/views/ 目录下：12345spring: mvc: view: prefix: /WEB-INF/views/ suffix: .jsp 3.修改@RestController注解为@Controller，然后修改 php 方法： 12345678910111213/** * @Author: cp * @Date: 2019/1/19 下午4:38 * @Version 1.0 */@Controllerpublic class HelloWorldController &#123; @RequestMapping("/php") public String php(Model model)&#123; model.addAttribute("php","php是世界上最好的语言"); return "php"; &#125;&#125; 4.在src/main目录下依次创建webapp/WEB-INF/views目录，并创建一个 hello.jsp 文件： 123&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8" %&gt;谁是世界上最好的语言？&lt;br&gt;$&#123;php&#125; 再刷新页面就可以看到效果了。 4.2集成MyBatis1.在pox.xml中添加对mysql和mybatis对依赖123456789101112&lt;!-- mybatis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- mysql --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.21&lt;/version&gt;&lt;/dependency&gt; 2.在配置文件中添加配置12345678910111213spring: mvc: view: prefix: /WEB-INF/views/ suffix: .jsp datasource: url: jdbc:mysql://127.0.0.1:3306/test3?characterEncoding=UTF-8 username: root password: 20141232 driver-class-name: com.mysql.jdbc.Driver jpa: hibernate: ddl-auto: update 3.先在cn.edu.zzuli中创建domain包和mapper包，再创建Student实体类和StudentMapper映射类分别放入domain和mapper包,1234567891011121314151617181920212223242526272829package cn.edu.zzuli.domain;/** * @Author: cp * @Date: 2019/1/19 下午6:35 * @Version 1.0 */public class Student &#123; int id; String name; int age; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 123456789101112131415161718package cn.edu.zzuli.mapper;import cn.edu.zzuli.domain.Student;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Select;import java.util.List;/** * @Author: cp * @Date: 2019/1/19 下午6:41 * @Version 1.0 */@Mapperpublic interface StudentMapper &#123; @Select("select * from student") List&lt;Student&gt; findAll();&#125; 4.写一个StudentContorller 123456789101112131415161718192021222324252627package cn.edu.zzuli.Controller;import cn.edu.zzuli.domain.Student;import cn.edu.zzuli.mapper.StudentMapper;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import java.util.List;/** * @Author: cp * @Date: 2019/1/19 下午6:44 * @Version 1.0 */@Controllerpublic class StudentController &#123; @Autowired StudentMapper studentMapper; @RequestMapping("/studentlist") public String studentlist(Model model)&#123; List&lt;Student&gt; students=studentMapper.findAll(); model.addAttribute("list",students); return "list"; &#125;&#125; 5.写一个list.jsp文件 1234567891011121314151617&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%&gt;&lt;table align='center' border='1' cellspacing='0'&gt; &lt;tr&gt; &lt;td&gt;id&lt;/td&gt; &lt;td&gt;name&lt;/td&gt; &lt;/tr&gt; &lt;c:forEach items="$&#123;list&#125;" var="s" varStatus="st"&gt; &lt;tr&gt; &lt;td&gt;$&#123;s.id&#125;&lt;/td&gt; &lt;td&gt;$&#123;s.name&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt;&lt;/table&gt; 刷新网络，大功告成。 以上就是springboot的搭建，随后的时间里会对Springboot的其他模块进行更深入的探索。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F01%2F17%2Fhello-world%2F</url>
    <content type="text"><![CDATA[我的第一篇博客]]></content>
  </entry>
</search>
