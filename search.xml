<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SpringBoot-使用QueryDSL查询框架]]></title>
    <url>%2F2019%2F01%2F22%2FSpringBoot-%E4%BD%BF%E7%94%A8QueryDSL%E6%9F%A5%E8%AF%A2%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[SpringBoot-使用QueryDSL查询框架(基础) QueryDSL是一个通用的查询框架，框架的核心原则是创建安全类型的查询，开始QueryDSL仅支持Hibernate（HQL），在不断开源人士加入QueryDSL团队后，陆续发布了针对JPA，JDO，JDBC，Lucene，Hibernate Search，MangoDB，Collections 和RDF(Relational Data Format) Bean等。 简述&emsp;&emsp;在使用SpringDataJPA的时候，内置的QueryByExampleExecutor对复杂查询来说显然不怎么好用，于是在这里引入一个便于我们进行复杂查询的框架————QueryDSL。这个框架可以完美的和SpringDataJPA进行融合，接下来主要说怎么用。 项目构建&emsp;&emsp;怎么搭建SpringBoot、数据源、数据库连接、配置SpringDataJPA就不说了，在原先的基础上添加项目依赖。12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;com.querydsl&lt;/groupId&gt; &lt;artifactId&gt;querydsl-jpa&lt;/artifactId&gt; &lt;version&gt;4.0.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.querydsl&lt;/groupId&gt; &lt;artifactId&gt;querydsl-apt&lt;/artifactId&gt; &lt;version&gt;4.2.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.inject&lt;/groupId&gt; &lt;artifactId&gt;javax.inject&lt;/artifactId&gt; &lt;version&gt;1&lt;/version&gt;&lt;/dependency&gt; 仅仅添加依赖还不够，我们需要在下面的&lt;plugins&gt;标签中添加插件 1234567891011121314151617&lt;!--该插件生成查询对象--&gt; &lt;plugin&gt; &lt;groupId&gt;com.mysema.maven&lt;/groupId&gt; &lt;artifactId&gt;apt-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.1.3&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;process&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;outputDirectory&gt;target/generated-sources/java&lt;/outputDirectory&gt; &lt;processor&gt;com.querydsl.apt.jpa.JPAAnnotationProcessor&lt;/processor&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; 然后在idea界面右上角打开Edit Configurations,新建一个maven，填入如图所示信息。在右上角启动这个插件。该插件会自动扫描项目内配置了@Entity的实体类，并根据实体的内定义的字段以及关联类通过JPAAnnotationProcessor自动创建Q[实体类名称]的查询实体，创建完成后会将实体存放到我们配置outputDirectory属性目录下。如图所示。 准备准备数据库信息&emsp;&emsp;先构建一个普通的User实体类,项目启动时会自动根据这个实体类建表，建表后向里面扔几条测试数据。123456789101112131415161718192021/** * @Author: cp * @Date: 2019/1/21 下午11:13 * @Version 1.0 */@Entity@Table(name = "user")public class User implements Serializable &#123; @Id @Column(name = "id") @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; @Column(name = "name") private String name; @Column(name = "age") private String age; @Column(name = "address") private String address; @Column(name = "pwd") private String pwd; /*setter and getter*/ 创建基类JPA&emsp;&emsp;正如上一篇所说，正常情况下一个项目肯定不可能就继承一个JpaRepository接口，再使用其他模块时还需要多个接口继承，如果每一个业务数据接口都继承几个相同的接口的话，对于系统设计和代码复用性来说不是个什么好的选择。所以我们需要一个基类JPA。12345678/** * @Author: cp * @Date: 2019/1/21 下午11:16 * @Version 1.0 */@NoRepositoryBeanpublic interface BaseJPA&lt;T&gt; extends JpaRepository&lt;T,Integer&gt;,JpaSpecificationExecutor&lt;T&gt;,QuerydslPredicateExecutor&lt;T&gt; &#123;&#125; @NoRepositoryBean是为了避免自动实例化。 创建对应模块JPA&emsp;&emsp;创建对应User模块的数据逻辑接口JPA，因为BaseJPA已经继承了我们所需要的所有接口，所以我们只需要继承BaseJPA就可以了。1234567/** * @Author: cp * @Date: 2019/1/21 下午11:18 * @Version 1.0 */public interface UserJPA extends BaseJPA&lt;User&gt; &#123;&#125; 执行插件生成Q结构查询实体&emsp;&emsp;这个不多说了，刚才生成过了。打开自动创建的实体后可以看到QueryDSL自动为我们创建的查询字段以及构造函数。 编写控制器&emsp;&emsp;为了方便我就不写Service层了，所有业务逻辑全部放在Controller层，不过正式开发时一定要写。12345678910111213141516/** * @Author: cp * @Date: 2019/1/21 下午11:20 * @Version 1.0 */@RestControllerpublic class UserController &#123; @Autowired private UserJPA userJPA; @Autowired private EntityManager entityManager; private JPAQueryFactory queryFactory; @PostConstruct public void initFactory()&#123; queryFactory=new JPAQueryFactory(entityManager); &#125; 声明EntityManager的注入以及JPAQueryFactory工厂对象的创建，通过@PostConstruct注解在类初始化的时候完成对JPAQueryFactory对象的实例化。 查询查询并排序12345678@RequestMapping(value = "/queryAll")public List&lt;User&gt; queryAll()&#123; QUser qUser=QUser.user;//创建查询对象 return queryFactory//查询并返回 .selectFrom(qUser)//源 .orderBy(qUser.id.desc())//根据id倒序 .fetch();//执行并返回结果集&#125; &emsp;&emsp;queryAll方法内首先获取了对应UserBean的查询实体QUserBean，通过QUserBean内自动生成的字段获取，我们使用JPAQueryFactory工厂对象的selectFrom方法来简化查询，该方法代替了select&amp;from两个方法，注意：也是仅限单表操作时可以使用。&emsp;&emsp;这样写起来感觉就像在写原生SQL，在一系列的条件都添加完成后，调用fetch方法执行我们的条件查询并且获取对应selectFrom查询实体的类型集合，要注意一点：这里如果selectFrom参数的实体类型不是User那fetch方法返回集合的类型也不是List&lt;User&gt;。&emsp;&emsp;启动后访问这个方法就可以在网页中见到这些数据，同时在控制台中也可以看见生成的SQL语句。1234567891011Hibernate: select user0_.id as id1_3_, user0_.address as address2_3_, user0_.age as age3_3_, user0_.name as name4_3_, user0_.pwd as pwd5_3_ from user user0_ order by user0_.id desc 根据主键查询数据&emsp;&emsp;这个方法是最常用的方法，现在我们有两种写法，一种是使用QueryDSL，另外一种是和SpringDataJPA结合。使用QueryDSL：12345678@RequestMapping(value = "/detail/&#123;id&#125;")public User detail(@PathVariable("id") Integer id)&#123; QUser qUser=QUser.user;//使用querydsl return queryFactory .selectFrom(qUser)//源 .where(qUser.id.eq(id))//条件 .fetchOne();//结果&#125; SpringDataJPA+QueryDSL:12345@RequestMapping(value = "/detail_2/&#123;id&#125;") public Optional&lt;User&gt; detail_2(@PathVariable("id") Integer id)&#123; QUser qUser=QUser.user;//使用querydsl return userJPA.findOne(qUser.id.eq(id));//查询并返回结果 &#125; 网上的一些教程关于SpringDataJPA+QueryDSL的方法返回值好多都是直接返回实体类，不过最新的方法已经修改为返回Optional类，用来解决万恶的空指针异常。&emsp;&emsp;这两种代码效果是一样的，都是根据主键返回对应信息，看起来SpringDataJPA+QueryDSL还简单一点，不过这只限于单表查询，一旦涉及各种复杂操作还是QueryDSL简单。在使用QueryDSL查询指定主键时，我们使用了where方法并且指定了id字段需要eq参数id，这个eq是QueryDSL内置的一个方法，用于查询指定值数据，当然其他字段也同样可以使用eq方法来完成条件查询，都是可以变通使用的。 模糊查询&emsp;&emsp;根据name字段模糊查询。12345678@RequestMapping(value = "like")public List&lt;User&gt; likeQueryByName(String name)&#123; QUser qUser=QUser.user;//使用querydsl return queryFactory .selectFrom(qUser)//源 .where(qUser.name.like("%"+name+"%"))//条件 .fetch();&#125; like是QueryDSL内置方法，只要存入条件，就可以完成模糊查询，可以看一下控制台输出的SQL语句。1234567891011Hibernate: select user0_.id as id1_3_, user0_.address as address2_3_, user0_.age as age3_3_, user0_.name as name4_3_, user0_.pwd as pwd5_3_ from user user0_ where user0_.name like ? escape '!' 更新使用SpringDataJPA更新实体&emsp;&emsp;与Hibernate一样，SpringDataJPA内置了一个save方法用于保存、更新实体内容，如果存在主键值则更新对应信息，反则是添加一条新信息。我们新添加一个方法。12345678910@RequestMapping(value = "/updateJPA")public String updateJPA()&#123; User user=new User(); user.setId(1); user.setName("王五"); user.setAge("13"); user.setPwd("321"); userJPA.save(user); return "success";&#125; 很简单，并没有什么难理解的地方，直接访问这个方法就可以看结果了，重点是先看控制台输出的SQL语句，首先输出了一条查询语句。12345678910select user0_.id as id1_3_0_, user0_.address as address2_3_0_, user0_.age as age3_3_0_, user0_.name as name4_3_0_, user0_.pwd as pwd5_3_0_ from user user0_ where user0_.id=? 这是因为SpringDataJPA先去查询数据库中有没有这个主键的信息，如果有，才会执行下面的更新语句。123456789update user set address=?, age=?, name=?, pwd=? where id=? 使用QueryDsl更新实体1234567891011121314151617181920@Transactional@RequestMapping(value = "updateDsl")public String updateByQueryDsl()&#123; User user=new User(); user.setPwd("090"); user.setAge("80"); user.setName("赵四"); user.setId(1); user.setAddress("北京"); QUser qUser=QUser.user; queryFactory .update(qUser) .set(qUser.name,user.getName()) .set(qUser.address,user.getAddress()) .set(qUser.age,user.getAge()) .set(qUser.pwd,user.getPwd()) .where(qUser.id.eq(user.getId())) .execute(); return "SUCCESS";&#125; &emsp;&emsp;与SpringDataJPA不同的是，使用save方法的时候，如果实体类中某一条是空的，那么数据库中对应字段也会被设为空，而使用QueryDsl时就可以随心所欲的选择只更新某几条信息。设置完成更新字段后需要设置更新的条件，不设置也是可以的，当然这里肯定跟原生SQL一样，不设置条件就更新表内全部的数据。最后使用execute()执行操作就行了。 敲黑板：在执行update/delete方法时必须添加事务，也就是@Transactional注解，否则会抛出异常。 这是控制台输出的语句。12345678910Hibernate: update user set name=?, address=?, age=?, pwd=? where id=? 删除使用SpringDataJPA删除实体信息1234567@RequestMapping(value = "/deletejpa")public String deletejpa()&#123; User user=new User(); user.setId(4); userJPA.deleteById(user.getId());//删除指定主键的值 return "success";&#125; &emsp;&emsp;简单粗暴，不用解释。 使用QueryDsl删除实体信息123456789101112@Transactional//这个必须有@RequestMapping(value = "/deletequery")public String deleteQueryDsl()&#123; User user=new User(); user.setId(4); QUser qUser=QUser.user; queryFactory .delete(qUser)//删除 .where(qUser.id.eq(user.getId()))//条件 .execute();//执行 return "sueecss";&#125; &emsp;&emsp;跟update方法差不多，就是把update改成delete，看起来好像比SpringDataJPA还麻烦了，但是我们引入这个框架是为了复杂查询，所以我们加一个限定条件，删除id大于四，且name值为王五的人。123456789101112131415@Transactional//这个必须有@RequestMapping(value = "/deletequeryid")public String deletequeryById()&#123; User user=new User(); user.setName("mvm"); QUser qUser=QUser.user; queryFactory .delete(qUser)//删除 .where( qUser.name.eq(user.getName()) .and(qUser.id.gt(4))//条件 ) .execute();//执行 return "success";&#125; SpringDataJPA想要完成这个就没那么简单了，看一下生成的SQL语句。1234567Hibernate: delete from user where name=? and id&gt;? 还是很规范的，输出的SQL完全根据我们设置的条件来自动生成，QueryDsl内的条件可以跟原生SQL完全一样，可以完全采用SQL的思想来编写条件。 最后&emsp;&emsp;以上是SpringDataJPA结合QueryDSL的基础操作，后续还会继续学习多表关联查询、自定义返回对象、聚合查询、子查询等复杂操作。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>SpringDataJPA</tag>
        <tag>QueryDSL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot----整合SpringDataJPA]]></title>
    <url>%2F2019%2F01%2F21%2FSpringBoot-%E6%95%B4%E5%90%88SpringDataJPA%2F</url>
    <content type="text"><![CDATA[SpringBoot-整合SpringDataJPA1.简述&emsp;&emsp;SpringDataJPA是Spring Data的一个子项目，默认底层是Hibernate，使用基于JPA的Repository,极大的减少对数据库访问的代码量，仅仅使用内部接口就可以完成简单的crud操作。 2.搭建项目&emsp;&emsp;还使用之前搭好的框架进行测试，由于是测试，为了方便就不搭建Service层了，所有逻辑代码都放在了Controller层，数据源使用alibaba的Druid数据源，关于Druid以后慢慢说，不放在这里讨论。 2.1导入依赖并修改配置文件&emsp;&emsp;首先在pom.xml原来的基础中添加配置。123456789&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.12&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt; 然后修改配置文件，添加关于Druid和SpringBootJPA的依赖123456789101112131415161718192021222324252627282930313233343536spring: mvc: view: prefix: /WEB-INF/views/ suffix: .jsp datasource: type: com.alibaba.druid.pool.DruidDataSource url: jdbc:mysql://127.0.0.1:3306/test3?characterEncoding=UTF-8 username: root password: 20141232 driver-class-name: com.mysql.jdbc.Driver #最大活跃数 maxaActive: 20 #初始化数量 InitialSize: 1 #最大连接等待时间 maxWait: 60000 #打开PSCache，并指定大小 poolPreparedStatements: true maxPoolPreparedStatementPerConnectionSize: 20 minIdle: 1 connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: select 1 from dual testWhileIdle: true testOnBorrow: false testOnReturn: false filters: stat, wall, log4j jpa: properties: hibernate: hbm2ddl: auto: update show_sql: true format_sql: true 之后还需要在入口文件ZzuliApplication中添加两条注解。12345678@SpringBootApplication@EnableAutoConfiguration@ComponentScan(basePackages = &#123;"cn.edu.zzuli"&#125;)public class ZzuliApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ZzuliApplication.class, args); &#125;&#125; @EnableAutoConfiguration禁止掉多数据源的自动注入，如果不这样做就会产生maven的依赖包冲突，导致重复依赖。@ComponentScan会扫描指定包，在指定包中寻找带注解的类。 2.2 使用JpaRepository&emsp;&emsp;与Hibernate一样，都需要一个实体类对数据库表结构进行映射，在启动项目时，会对实体类创建相应的表结构。所以先在domain包里创建StudentEntity类，get和set方法在此省略了。1234567891011121314151617181920212223242526272829package cn.edu.zzuli.domain;import cn.edu.zzuli.base.BaseEntity;import javax.persistence.*;import java.io.Serializable;/** * @Author: cp * @Date: 2019/1/20 下午3:56 * @Version 1.0 */@Entity@Table(name = "studentEntity")public class StudentEntity implements Serializable &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = "s_id") private Integer id; @Column(name = "s_name") private String name; @Column(name = "s_age") private Integer age; @Column(name = "s_address") private String address; /*getter and setter*/&#125; 对这几个注解做一下说明，使用@Entity会对实体类进行持久化操作，当JPA检测到实体类中有@Entity注解时，会在数据库中生成对应的表结构信息。@Table用来指定表名，@Id用来指定主键，配合@GeneratedValue(strategy = GenerationType.IDENTITY)指定主键自增策略，这里将主键自增交给数据库去做，所以使用IDENTITY，@Column用来指定对应表中的字段名。&emsp;&emsp;之后我们需要创建StudentJPA接口,先创建一个jpa包，在下面创建StudentJPA接口，继承JpaRepository，需要两个参数，一个是实体类对象，一个是主键类型。1234567/** * @Author: cp * @Date: 2019/1/20 下午4:01 * @Version 1.0 */public interface StudentJPA extends JpaRepository&lt;StudentEntity,Integer&gt; &#123;&#125; 我们查看JpaRepository就可以看到这个接口又继承了PagingAndSortingRepository和QueryByExampleExecutor接口，PagingAndSortingRepository又继承了CrudRepository接口，浓浓的Spring风格，基本上看名字就知道这个接口大概是干什么的，至于为什么这么设计，那就是架构的问题了。 2.1.1 CrudRepository&emsp;&emsp;看名字就知道，这个接口中包含了crud操作，也就是creat、select、delete、update、exist、count.1234567891011121314@NoRepositoryBeanpublic interface CrudRepository&lt;T, ID&gt; extends Repository&lt;T, ID&gt; &#123; &lt;S extends T&gt; S save(S var1); &lt;S extends T&gt; Iterable&lt;S&gt; saveAll(Iterable&lt;S&gt; var1); Optional&lt;T&gt; findById(ID var1); boolean existsById(ID var1); Iterable&lt;T&gt; findAll(); Iterable&lt;T&gt; findAllById(Iterable&lt;ID&gt; var1); long count(); void deleteById(ID var1); void delete(T var1); void deleteAll(Iterable&lt;? extends T&gt; var1); void deleteAll();&#125; 如果继承该接口就会拥有所有该接口的实现。 2.1.2 PagingAndSortingRepository&emsp;&emsp;顾名思义，分页和排序，而且继承了CrudRepository接口，拥有其所有的接口实现。12345@NoRepositoryBeanpublic interface PagingAndSortingRepository&lt;T, ID&gt; extends CrudRepository&lt;T, ID&gt; &#123; Iterable&lt;T&gt; findAll(Sort var1); Page&lt;T&gt; findAll(Pageable var1);&#125; 2.1.3 QueryByExampleExecutor&emsp;&emsp;这个接口就是实现条件查询和复杂查询的，可以使用exmple的方式查询。12345678public interface QueryByExampleExecutor&lt;T&gt; &#123; &lt;S extends T&gt; Optional&lt;S&gt; findOne(Example&lt;S&gt; var1); &lt;S extends T&gt; Iterable&lt;S&gt; findAll(Example&lt;S&gt; var1); &lt;S extends T&gt; Iterable&lt;S&gt; findAll(Example&lt;S&gt; var1, Sort var2); &lt;S extends T&gt; Page&lt;S&gt; findAll(Example&lt;S&gt; var1, Pageable var2); &lt;S extends T&gt; long count(Example&lt;S&gt; var1); &lt;S extends T&gt; boolean exists(Example&lt;S&gt; var1);&#125; 但是我感觉这个东西不怎么好用，以后会有替代品。 2.1.4 JpaRepository&emsp;&emsp;我们用的就是这个接口，它拥有以上所有接口的方法实现，并添加了条件查询和保存集合数据的方法，基本上简单的数据库操作就不需要写SQL了。1234567891011121314@NoRepositoryBeanpublic interface JpaRepository&lt;T, ID&gt; extends PagingAndSortingRepository&lt;T, ID&gt;, QueryByExampleExecutor&lt;T&gt; &#123; List&lt;T&gt; findAll(); List&lt;T&gt; findAll(Sort var1); List&lt;T&gt; findAllById(Iterable&lt;ID&gt; var1); &lt;S extends T&gt; List&lt;S&gt; saveAll(Iterable&lt;S&gt; var1); void flush(); &lt;S extends T&gt; S saveAndFlush(S var1); void deleteInBatch(Iterable&lt;T&gt; var1); void deleteAllInBatch(); T getOne(ID var1); &lt;S extends T&gt; List&lt;S&gt; findAll(Example&lt;S&gt; var1); &lt;S extends T&gt; List&lt;S&gt; findAll(Example&lt;S&gt; var1, Sort var2);&#125; 3.测试3.1 创建Controller层&emsp;&emsp;在controller 包中新建JPAStudentController类，这回测试就不使用JSP了，直接带上@RestController注解，并注入StudentJPA，返回json格式验证数据。12345678910/** * @Author: cp * @Date: 2019/1/20 下午4:06 * @Version 1.0 */@RestControllerpublic class JPAStudentController &#123; @Autowired private StudentJPA studentJPA;&#125; 3.2开启测试3.1.1 查询&emsp;&emsp;在JPAStudentController中添加list方法，使用JpaRepository内部实现的findAll方法。1234@RequestMapping(value = "/stu")public List&lt;StudentEntity&gt; list() &#123; return studentJPA.findAll();&#125; 接着在浏览器访问访问localhost:8080/stu，可以看到页面返回的数据。可以看到我在数据库预先准备的数据。&emsp;&emsp;除此之外，只要继承JpaRepository接口，我们还能使用方法规则进行查询，我第一次见的时候感觉挺神奇的，举个栗子，我在StudentJPA中定义StudentEntity findByName(String name);方法，他就可以直接被解析为。1select from StudentEntity where name=? 超级方便，简单的查询直接写定义这么一个方法就好了，不过弊端就是对于复杂查询，方法名会超级长，而且很难实现。&emsp;&emsp;如果想对SQL语句进行细致优化的话，我们还可以使用@Query注解自定义SQL。打开StudentJPA，在其中添加以年龄为条件的查询。12@Query(value = "select * from student_entity where s_age&gt;=?",nativeQuery = true)public List&lt;StudentEntity&gt; SelectByAge(int age); nativeQuery这个设置为true表明使用原生SQL，否则默认启用HQL。在controller层添加代码。1234@RequestMapping(value = "/age")public List&lt;StudentEntity&gt; age()&#123; return studentJPA.SelectByAge(20);&#125; 重启项目并在浏览器中输入localhost:8080/age。 3.1.2 增加&emsp;&emsp;增加数据只需要将实体类当作参数，调用StudentJPA的save方法即可。123456789@RequestMapping(value = "/add") public String add()&#123; StudentEntity entity=new StudentEntity(); entity.setAddress("郑州轻工业大学"); entity.setAge(19); entity.setName("范秉洋"); studentJPA.save(entity); return "添加成功"; &#125; save方法不仅仅用于增加，如果实体类中传入主键，那么save方法就会变为根据主键更新数据库操作，下面就不再写更新的方法了。 3.1.3 删除&emsp;&emsp;直接使用JpaRepository提供的deleteById方法即可。12345@RequestMapping(value = "/delete")public String delete(Integer userId)&#123; studentJPA.deleteById(userId); return "删除成功";&#125; 3.1.4 自定义语句&emsp;&emsp;如同在查询中使用@Query注解一样，增删改查都可以使用原生SQL对数据库操作，不过@Query只能查询，那么就需要配合另一个注解@Modifying一起使用。创建一个根据姓名和年龄删除数据的方法。123@Modifying@Query(value = "delete from student_entity where s_name=? and s_age=?",nativeQuery = true)public void deleteQuery(String name,Integer age); 如果这么写的话，会抛出一个TranscationRequiredException异常，意思就是当前操作需要事务，所以要在这个方法前加@Transactional开启自动化管理。 3.1.5 自定义BaseRepository&emsp;&emsp;正常情况下一个项目肯定不可能就继承一个JpaRepository接口，再使用其他模块时还需要多个接口继承，如果每一个业务数据接口都继承几个相同的接口的话，不是不可以，但是对于系统设计和代码复用性来说不是个什么好的选择。&emsp;&emsp;创建一个叫base的包，在里面添加BaseRepository接口，并继承JpaRepository。12345678/** * @Author: cp * @Date: 2019/1/20 下午10:29 * @Version 1.0 */@NoRepositoryBeanpublic interface BaseRepository&lt;T,PK extends Serializable&gt; extends JpaRepository&lt;T,PK&gt; &#123;&#125; @NoRepositoryBean:这个注解如果配置在继承了JpaRepository接口以及其他SpringDataJpa内部的接口的子接口时，子接口不被作为一个Repository创建代理实现类。 以后再创建接口继承BaseRepository就行了，他有JpaRepository所有实现方法。 3.1.6 分页查询&emsp;&emsp;对于一般项目来说分页是少不了的，当然，SpringDataJPA也内置了分页方法。&emsp;&emsp;先创建一个BaseEntity，添加几个字段：当前页码、每页条数、排序列，排序方法。12345678910111213141516171819202122232425/** * @Author: cp * @Date: 2019/1/20 下午10:45 * @Version 1.0 */public class BaseEntity &#123; /** * 默认页码 */ protected int page=1; /** * 默认分页数量 */ protected int size=2; /** * 排序列名为id */ protected String sidx="id"; /** * 排序规则 * @return */ protected String sord="desc"; /*getter and setter*/&#125; 修改StudentEntity类继承BaseEntity,由于数据不多，所以设定一页就两条。在JPAStudentController中添加cut方法，并添加对应分页逻辑。注意在分页中页码是从0开始的。1234567@RequestMapping(value = "/page") public List&lt;StudentEntity&gt; Page(Integer page)&#123; StudentEntity entity=new StudentEntity(); entity.setSize(2); entity.setPage(page); return studentJPA.findAll(PageRequest.of(entity.getPage()-1,entity.getSize())).getContent(); &#125; 从网上找的分页方法是使用PageRequest对象，不过使用时发现这个方法的构造方法在最新版本中被废弃了，查看源码后得知取而代之的是静态的PageRequest.of()方法。接下来重启项目并访问该方法。 3.1.6 排序&emsp;&emsp;BaseEntity预设好了对应字段，所以重新编辑page方法，将Sort对象添加在PageRequest.of()中就可以实现排序。12345678910111213@RequestMapping(value = "/page") public List&lt;StudentEntity&gt; Page(Integer page)&#123; StudentEntity entity=new StudentEntity(); entity.setSize(2); entity.setPage(page); entity.setSord("desc"); //获取排序对象 Sort.Direction sort_Direction=Sort.Direction.ASC.toString().equalsIgnoreCase(entity.getSord())?Sort.Direction.ASC:Sort.Direction.DESC; //设置排序对象 Sort sort=new Sort(sort_Direction,entity.getSidx()); //执行分页 return studentJPA.findAll(PageRequest.of(entity.getPage()-1,entity.getSize(),sort)).getContent(); &#125; 我们现在将顺序按照id倒序排序，SpringDataJPA对排序方式添加了一个枚举类型，创建Sort对象时也需要枚举对象，因为我们BaseEntity配置的是字符串所以上面多了一步判断排序方式返回枚举对象。重启项目。 4.总结&emsp;&emsp;基本操作就这么多了，包括了：CURD、分页、排序、自定义SQL、定义BaseRepository、事务处理等。用起来还是挺方便的，但是这并不是全部，后面还会对一对多、多对多等复杂查询进行总结，今天就先到这里吧。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>SpringDataJPA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot----快速搭建]]></title>
    <url>%2F2019%2F01%2F19%2FSpringBoot-%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[SpringBoot-快速搭建1.SpringBoot简述 Spring Boot makes it easy to create stand-alone production-grade Spring based Applications that you can “just run”.We take an opinionated view of the Spring platform and third-party libraries so you can get started with minimum fuss. Most Spring Boot applications need very little Spring configuration. &emsp;&emsp;摘自官网,大致意思是创建独立的、快速的、生产级的基于Spring的应用，对Spring和第三方库进行整合，轻松上手，只需要很少的配置就可以使用。 1.1优势&emsp;&emsp;在之前使用SSH(都9102年了我估计也没多少人用Struts了吧)与SSM时，虽然相对于传统的JSP+servlet+jdbc的开发模式简化了开发流程，但是在项目初期搭建的时候相当繁琐，大致需要： 1.配置xml，加载一坨配置文件. 2.配置Spring和SpringMVC，这两个还好，可以写到一个里面，配置Struts那是相当难受. 3.配置数据源，配置日志文件. 4.配置Mybatis的Mapper文件和Hibernate的配置文件 5.各种动态扫描注解 …… &emsp;&emsp;如果是在我学Django之前,我还是可以忍受这种东西的，但是学完Django之后，这种繁琐的配置就让人觉得很难受，我一直期望着Java中有一个和Django一样一个框架就可以干完所有活而且配置还非常简单的框架。得益于我喜欢在知(bi)乎上瞎逛，我了解了SpringBoot相关的技术链，并在禹州实训期间闲的没事干的情况下蹦入了这个坑，试了之后就一个字————爽！&emsp;&emsp;基本全程就几个配置文件，而且都不是xml，所有配置都是自动配置的，而且它内置tomcat，在使用idea的情况下，idea内置的各种工具可以实现全部框架的自动生成，再这里吹一波JetBrain。 突出优势：简单、快速、方便的搭建项目主流开发框架无配置集成提高开发、部署效率 2.项目搭建2.1开发环境 os:MacOS 10.13.4 ide:IDEA 2018.1.4 jdk:10.0.1 maven:3.3.9 tomcat:9.0(框架自带) 2.2新建项目&emsp;&emsp;新建项目时，点击左侧的Spring Initializr,然后点击next。 &emsp;&emsp;下一个页面是修改项目信息，第一个参数Group的域，第二个参数Artifact一般代表公司名称，这两个参数都是提供给maven的。最后一个参数Package为项目总包名，余下几个参数，Type一般都选择maven，Languge一般选择Java，也可以使用其他虚拟机语言，比如Kotlin、Groovy。Packing是打包方式，可以选择打成jar包或者war包 钩上web模版选择位置&emsp;&emsp;因为依托与maven，第一次加载时间可能比较长，因为所有配置需要从网络上去拉取，下载完毕后文件目录如图所示。看一下目录，大致分为三块： java文件：代码源文件，逻辑代码都在这里，里面那个ZzuliApplicaion是系统入口文件。 resource文件：静态资源文件，里面放着所有的静态资源和配置文件，application.properties中可以添加其他配置。 test文件：测试模块，里面内涵一个Junit测试。 外面有一个pom.xml文件，这个是maven的配置文件。 2.3 测试运行&emsp;&emsp;在之前创建的cn.edu.zzuli文件夹下创建Controller文件夹，并创建HelloWorldController类进行测试。1234567891011121314151617package cn.edu.zzuli.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;/** * @Author: cp * @Date: 2019/1/19 下午4:38 * @Version 1.0 */@RestControllerpublic class HelloWorldController &#123; @RequestMapping("/php") public String php()&#123; return "php是世界上最好的语言"; &#125;&#125; 基本上还是和SpringMVC很像的，唯一一点不同就是@RestController注解，这个注解就是原来@Controller和@ResponseBody注解的合体版。&emsp;&emsp;直接点击右上角的箭头或者启动ZzuliApplicaion类。出现这个界面就说明SpringBoot启动成功了。接着在浏览器中直接访问http://localhost:8080/php信息已被返回。 3.分析项目3.1 pox.xml文件&emsp;&emsp;SpringBoot自动生成的pox.xml文件如下12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.2.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;cn.edu&lt;/groupId&gt; &lt;artifactId&gt;zzuli&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;zzuli&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 相较于一般的pox.xml文件，这里多了一个&lt;parent&gt;标签,这个标签是在配置SpringBoot的父级依赖,有了这个，当前的项目才是SpringBoot项目，spring-boot-starter-parent是一个特殊的starter，它用来提供相关的maven默认依赖，使用它之后，常用的包依赖就可以省去version标签。&emsp;&emsp;\repository\org\springframework\boot\spring-boot-dependencies\2.0.1.RELEASE\spring-boot-dependencies-2.0.1.RELEASE.pom里面有SpringBoot的所有依赖，想了解的去这里看看 3.2 入口类&emsp;&emsp;SpringBoot项目通常有一个名为*Application的入口类，入口类里有一个main方法，这个main方法其实就是一个标准的Java应用的入口方法。&emsp;&emsp;@SpringBootApplication是SpringBoot的核心注解，它是一个组合注解，该注解组合了：@Configuration、@EnableAutoConfiguration、@ComponentScan若不是用@SpringBootApplication注解也可以使用这三个注解代替。&emsp;&emsp;其中，EnableAutoConfiguration让SpringBoot根据类路径中的jar包依赖为当前项目进行自动配置，例如，添加了spring-boot-starter-web依赖，会自动添加Tomcat和SpringMVC的依赖，那么SpringBoot会对Tomcat和SpringMVC进行自动配置。&emsp;&emsp;SpringBoot还会自动扫描@SpringBootApplication所在类的同级包以及下级包里的Bean，所以入口类建议就配置在grounpID+arctifactID组合的包名下（这里为cn.edu.zzuli包），使用idea自动创建项目的话idea会自动在这里创建。 3.3 配置文件&emsp;&emsp;SpringBoot使用一个全局的配置文件application.properties或application.yml，放置在src/main/resources目录或者类路径的/config下。&emsp;&emsp;SpringBoot不仅支持常规的properties配置文件，还支持yaml语言的配置文件。yaml是以数据为中心的语言，在配置数据的时候具有面向对象的特征。&emsp;&emsp;SpringBoot的全局配置文件的作用是对一些默认配置的配置值进行修改。这里我将application.properties修改为application.yml。 4.使用SpringBoot&emsp;&emsp;上面只是一些简单的搭建以及运行，下面再深入了解一下SpringBoot的应用。SpringBoot的默认视图支持是 Thymeleaf 模板引擎。但是咱不会，只好还用JSP。 4.1集成JSP1.在pom.xml文件中集成JSP，向pom.xml中添加1234567891011121314&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 2.在application.yml文件配置视图解析器，将我们的 JSP 文件重定向到 /WEB-INF/views/ 目录下：12345spring: mvc: view: prefix: /WEB-INF/views/ suffix: .jsp 3.修改@RestController注解为@Controller，然后修改 php 方法： 12345678910111213/** * @Author: cp * @Date: 2019/1/19 下午4:38 * @Version 1.0 */@Controllerpublic class HelloWorldController &#123; @RequestMapping("/php") public String php(Model model)&#123; model.addAttribute("php","php是世界上最好的语言"); return "php"; &#125;&#125; 4.在src/main目录下依次创建webapp/WEB-INF/views目录，并创建一个 hello.jsp 文件： 123&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8" %&gt;谁是世界上最好的语言？&lt;br&gt;$&#123;php&#125; 再刷新页面就可以看到效果了。 4.2集成MyBatis1.在pox.xml中添加对mysql和mybatis对依赖123456789101112&lt;!-- mybatis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- mysql --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.21&lt;/version&gt;&lt;/dependency&gt; 2.在配置文件中添加配置12345678910111213spring: mvc: view: prefix: /WEB-INF/views/ suffix: .jsp datasource: url: jdbc:mysql://127.0.0.1:3306/test3?characterEncoding=UTF-8 username: root password: 20141232 driver-class-name: com.mysql.jdbc.Driver jpa: hibernate: ddl-auto: update 3.先在cn.edu.zzuli中创建domain包和mapper包，再创建Student实体类和StudentMapper映射类分别放入domain和mapper包,1234567891011121314151617181920212223242526272829package cn.edu.zzuli.domain;/** * @Author: cp * @Date: 2019/1/19 下午6:35 * @Version 1.0 */public class Student &#123; int id; String name; int age; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 123456789101112131415161718package cn.edu.zzuli.mapper;import cn.edu.zzuli.domain.Student;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Select;import java.util.List;/** * @Author: cp * @Date: 2019/1/19 下午6:41 * @Version 1.0 */@Mapperpublic interface StudentMapper &#123; @Select("select * from student") List&lt;Student&gt; findAll();&#125; 4.写一个StudentContorller 123456789101112131415161718192021222324252627package cn.edu.zzuli.Controller;import cn.edu.zzuli.domain.Student;import cn.edu.zzuli.mapper.StudentMapper;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import java.util.List;/** * @Author: cp * @Date: 2019/1/19 下午6:44 * @Version 1.0 */@Controllerpublic class StudentController &#123; @Autowired StudentMapper studentMapper; @RequestMapping("/studentlist") public String studentlist(Model model)&#123; List&lt;Student&gt; students=studentMapper.findAll(); model.addAttribute("list",students); return "list"; &#125;&#125; 5.写一个list.jsp文件 1234567891011121314151617&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%&gt;&lt;table align='center' border='1' cellspacing='0'&gt; &lt;tr&gt; &lt;td&gt;id&lt;/td&gt; &lt;td&gt;name&lt;/td&gt; &lt;/tr&gt; &lt;c:forEach items="$&#123;list&#125;" var="s" varStatus="st"&gt; &lt;tr&gt; &lt;td&gt;$&#123;s.id&#125;&lt;/td&gt; &lt;td&gt;$&#123;s.name&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt;&lt;/table&gt; 刷新网络，大功告成。 以上就是springboot的搭建，随后的时间里会对Springboot的其他模块进行更深入的探索。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F01%2F17%2Fhello-world%2F</url>
    <content type="text"><![CDATA[我的第一篇博客]]></content>
  </entry>
</search>
